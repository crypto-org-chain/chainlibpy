# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Tell mypy (a type checker) to ignore all errors from this file.
# See https://mypy.readthedocs.io/en/stable/config_file.html?highlight=ignore-errors#confval-ignore_errors
# mypy: ignore-errors

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime

# Used for default argument values
DEFAULT = object()


class RustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return rust_call(_UniFFILib.ffi_common_ad00_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return rust_call(_UniFFILib.ffi_common_ad00_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return rust_call(_UniFFILib.ffi_common_ad00_rustbuffer_free, self)

    def __str__(self):
        return "RustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def allocWithBuilder():
        """Context-manger to allocate a buffer using a RustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = RustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consumeWithStream(self):
        """Context-manager to consume a buffer using a RustBufferStream.

        The RustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = RustBufferStream(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer after consuming")
        finally:
            self.free()


class ForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "ForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class RustBufferStream(object):
    """
    Helper for structured reading of bytes from a RustBuffer
    """

    def __init__(self, rbuf):
        self.rbuf = rbuf
        self.offset = 0

    def remaining(self):
        return self.rbuf.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.rbuf.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        data = self.rbuf.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def readI8(self):
        return self._unpack_from(1, ">b")

    def readU8(self):
        return self._unpack_from(1, ">B")

    def readI16(self):
        return self._unpack_from(2, ">h")

    def readU16(self):
        return self._unpack_from(2, ">H")

    def readI32(self):
        return self._unpack_from(4, ">i")

    def readU32(self):
        return self._unpack_from(4, ">I")

    def readI64(self):
        return self._unpack_from(8, ">q")

    def readU64(self):
        return self._unpack_from(8, ">Q")

    def readFloat(self):
        v = self._unpack_from(4, ">f")
        return v

    def readDouble(self):
        return self._unpack_from(8, ">d")


class RustBufferBuilder(object):
    """
    Helper for structured writing of bytes into a RustBuffer.
    """

    def __init__(self):
        self.rbuf = RustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, numBytes):
        if self.rbuf.len + numBytes > self.rbuf.capacity:
            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)
        yield None
        self.rbuf.len += numBytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def writeI8(self, v):
        self._pack_into(1, ">b", v)

    def writeU8(self, v):
        self._pack_into(1, ">B", v)

    def writeI16(self, v):
        self._pack_into(2, ">h", v)

    def writeU16(self, v):
        self._pack_into(2, ">H", v)

    def writeI32(self, v):
        self._pack_into(4, ">i", v)

    def writeU32(self, v):
        self._pack_into(4, ">I", v)

    def writeI64(self, v):
        self._pack_into(8, ">q", v)

    def writeU64(self, v):
        self._pack_into(8, ">Q", v)

    def writeFloat(self, v):
        self._pack_into(4, ">f", v)

    def writeDouble(self, v):
        self._pack_into(8, ">d", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class RustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", RustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == RustCallStatus.CALL_SUCCESS:
            return "RustCallStatus(CALL_SUCCESS)"
        elif self.code == RustCallStatus.CALL_ERROR:
            return "RustCallStatus(CALL_ERROR)"
        elif self.code == RustCallStatus.CALL_PANIC:
            return "RustCallStatus(CALL_PANIC)"
        else:
            return "RustCallStatus(<invalid code>)"

def rust_call(fn, *args):
    # Call a rust function
    return rust_call_with_error(None, fn, *args)

def rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the FFIConverter for the error class that corresponds to the result.
    call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    if call_status.code == RustCallStatus.CALL_SUCCESS:
        return result
    elif call_status.code == RustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.err_buf.contents.free()
            raise InternalError("rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == RustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a RustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = FfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid RustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: RustBuffer, buf_ptr: *mut RustBuffer) -> int`
FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, RustBuffer, ctypes.POINTER(RustBuffer))
# Types conforming to `FfiConverterPrimitive` pass themselves directly over the FFI.
class FfiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

# Helper class for wrapper types that will always go through a RustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class FfiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consumeWithStream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with RustBuffer.allocWithBuilder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code,
# and the FFI Function declarations in a com.sun.jna.Library.
# This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
#
# XXX TODO: This will probably grow some magic for resolving megazording in future.
# E.g. we might start by looking for the named component in `libuniffi.so` and if
# that fails, fall back to loading it separately from `lib${componentName}.so`.

from pathlib import Path

def loadIndirect():
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    lib = libname.format("defi_wallet_core_common")
    path = str(Path(__file__).parent / lib)
    return ctypes.cdll.LoadLibrary(path)

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniFFILib = loadIndirect()
_UniFFILib.ffi_common_ad00_WalletCoinFunc_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_WalletCoinFunc_object_free.restype = None
_UniFFILib.common_ad00_WalletCoinFunc_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_WalletCoinFunc_new.restype = ctypes.c_void_p
_UniFFILib.common_ad00_WalletCoinFunc_derive_address.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_WalletCoinFunc_derive_address.restype = RustBuffer
_UniFFILib.common_ad00_WalletCoinFunc_get_coin_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_WalletCoinFunc_get_coin_type.restype = ctypes.c_uint32
_UniFFILib.common_ad00_WalletCoinFunc_get_eth_network.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_WalletCoinFunc_get_eth_network.restype = RustBuffer
_UniFFILib.ffi_common_ad00_SecretKey_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_SecretKey_object_free.restype = None
_UniFFILib.common_ad00_SecretKey_new.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_SecretKey_new.restype = ctypes.c_void_p
_UniFFILib.common_ad00_SecretKey_from_bytes.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_SecretKey_from_bytes.restype = ctypes.c_void_p
_UniFFILib.common_ad00_SecretKey_from_hex.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_SecretKey_from_hex.restype = ctypes.c_void_p
_UniFFILib.common_ad00_SecretKey_get_public_key_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_SecretKey_get_public_key_bytes.restype = RustBuffer
_UniFFILib.common_ad00_SecretKey_get_public_key_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_SecretKey_get_public_key_hex.restype = RustBuffer
_UniFFILib.common_ad00_SecretKey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_SecretKey_to_bytes.restype = RustBuffer
_UniFFILib.common_ad00_SecretKey_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_SecretKey_to_hex.restype = RustBuffer
_UniFFILib.common_ad00_SecretKey_to_address.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_SecretKey_to_address.restype = RustBuffer
_UniFFILib.ffi_common_ad00_HDWallet_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_HDWallet_object_free.restype = None
_UniFFILib.common_ad00_HDWallet_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_HDWallet_new.restype = ctypes.c_void_p
_UniFFILib.common_ad00_HDWallet_recover_wallet.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_HDWallet_recover_wallet.restype = ctypes.c_void_p
_UniFFILib.common_ad00_HDWallet_generate_wallet.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_HDWallet_generate_wallet.restype = ctypes.c_void_p
_UniFFILib.common_ad00_HDWallet_get_backup_mnemonic_phrase.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_HDWallet_get_backup_mnemonic_phrase.restype = RustBuffer
_UniFFILib.common_ad00_HDWallet_get_default_address.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_HDWallet_get_default_address.restype = RustBuffer
_UniFFILib.common_ad00_HDWallet_get_address.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_HDWallet_get_address.restype = RustBuffer
_UniFFILib.common_ad00_HDWallet_get_key.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_HDWallet_get_key.restype = ctypes.c_void_p
_UniFFILib.common_ad00_HDWallet_get_key_from_index.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_HDWallet_get_key_from_index.restype = ctypes.c_void_p
_UniFFILib.ffi_common_ad00_CosmosSDKClient_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_CosmosSDKClient_object_free.restype = None
_UniFFILib.common_ad00_CosmosSDKClient_new.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosSDKClient_new.restype = ctypes.c_void_p
_UniFFILib.common_ad00_CosmosSDKClient_broadcast_tx.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosSDKClient_broadcast_tx.restype = RustBuffer
_UniFFILib.common_ad00_CosmosSDKClient_get_account_balance.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosSDKClient_get_account_balance.restype = RustBuffer
_UniFFILib.common_ad00_CosmosSDKClient_get_account_details.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosSDKClient_get_account_details.restype = RustBuffer
_UniFFILib.common_ad00_CosmosSDKClient_get_denom_metadata.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosSDKClient_get_denom_metadata.restype = RustBuffer
_UniFFILib.common_ad00_CosmosSDKClient_simulate.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosSDKClient_simulate.restype = ctypes.c_uint64
_UniFFILib.ffi_common_ad00_CosmosParserWrapper_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_CosmosParserWrapper_object_free.restype = None
_UniFFILib.common_ad00_CosmosParserWrapper_new_base_parser.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosParserWrapper_new_base_parser.restype = ctypes.c_void_p
_UniFFILib.common_ad00_CosmosParserWrapper_new_crypto_org_parser.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosParserWrapper_new_crypto_org_parser.restype = ctypes.c_void_p
_UniFFILib.common_ad00_CosmosParserWrapper_new_luna_classic_parser.argtypes = (
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosParserWrapper_new_luna_classic_parser.restype = ctypes.c_void_p
_UniFFILib.common_ad00_CosmosParserWrapper_parse_proto_json_fee.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosParserWrapper_parse_proto_json_fee.restype = RustBuffer
_UniFFILib.common_ad00_CosmosParserWrapper_parse_proto_json_msg.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosParserWrapper_parse_proto_json_msg.restype = RustBuffer
_UniFFILib.common_ad00_CosmosParserWrapper_parse_protobuf_auto_info.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosParserWrapper_parse_protobuf_auto_info.restype = RustBuffer
_UniFFILib.common_ad00_CosmosParserWrapper_parse_protobuf_tx_body.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosParserWrapper_parse_protobuf_tx_body.restype = RustBuffer
_UniFFILib.ffi_common_ad00_EthAbiContract_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_EthAbiContract_object_free.restype = None
_UniFFILib.common_ad00_EthAbiContract_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_EthAbiContract_new.restype = ctypes.c_void_p
_UniFFILib.common_ad00_EthAbiContract_encode_bind.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_EthAbiContract_encode_bind.restype = RustBuffer
_UniFFILib.ffi_common_ad00_CosmosSigner_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_CosmosSigner_object_free.restype = None
_UniFFILib.common_ad00_CosmosSigner_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosSigner_new.restype = ctypes.c_void_p
_UniFFILib.common_ad00_CosmosSigner_sign_direct.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_CosmosSigner_sign_direct.restype = RustBuffer
_UniFFILib.ffi_common_ad00_EthSigner_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_EthSigner_object_free.restype = None
_UniFFILib.common_ad00_EthSigner_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_EthSigner_new.restype = ctypes.c_void_p
_UniFFILib.common_ad00_EthSigner_eth_sign_insecure.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_EthSigner_eth_sign_insecure.restype = RustBuffer
_UniFFILib.common_ad00_EthSigner_personal_sign.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_EthSigner_personal_sign.restype = RustBuffer
_UniFFILib.common_ad00_EthSigner_sign_typed_data.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_EthSigner_sign_typed_data.restype = RustBuffer
_UniFFILib.ffi_common_ad00_Client_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_Client_object_free.restype = None
_UniFFILib.common_ad00_Client_new_blocking.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_Client_new_blocking.restype = ctypes.c_void_p
_UniFFILib.common_ad00_Client_supply_blocking.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_Client_supply_blocking.restype = ctypes.c_uint64
_UniFFILib.common_ad00_Client_owner_blocking.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_Client_owner_blocking.restype = RustBuffer
_UniFFILib.common_ad00_Client_collection_blocking.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_Client_collection_blocking.restype = RustBuffer
_UniFFILib.common_ad00_Client_denom_blocking.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_Client_denom_blocking.restype = RustBuffer
_UniFFILib.common_ad00_Client_denom_by_name_blocking.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_Client_denom_by_name_blocking.restype = RustBuffer
_UniFFILib.common_ad00_Client_denoms_blocking.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_Client_denoms_blocking.restype = RustBuffer
_UniFFILib.common_ad00_Client_nft_blocking.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_Client_nft_blocking.restype = RustBuffer
_UniFFILib.common_ad00_get_single_msg_sign_payload.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_get_single_msg_sign_payload.restype = RustBuffer
_UniFFILib.common_ad00_build_signed_single_msg_tx.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_build_signed_single_msg_tx.restype = RustBuffer
_UniFFILib.common_ad00_get_msg_sign_payload.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_get_msg_sign_payload.restype = RustBuffer
_UniFFILib.common_ad00_build_signed_msg_tx.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_build_signed_msg_tx.restype = RustBuffer
_UniFFILib.common_ad00_get_nft_issue_denom_signed_tx.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_get_nft_issue_denom_signed_tx.restype = RustBuffer
_UniFFILib.common_ad00_get_nft_mint_signed_tx.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_get_nft_mint_signed_tx.restype = RustBuffer
_UniFFILib.common_ad00_get_nft_edit_signed_tx.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_get_nft_edit_signed_tx.restype = RustBuffer
_UniFFILib.common_ad00_get_nft_transfer_signed_tx.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_get_nft_transfer_signed_tx.restype = RustBuffer
_UniFFILib.common_ad00_get_nft_burn_signed_tx.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_get_nft_burn_signed_tx.restype = RustBuffer
_UniFFILib.common_ad00_get_account_details_blocking.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_get_account_details_blocking.restype = RustBuffer
_UniFFILib.common_ad00_get_account_balance_blocking.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_get_account_balance_blocking.restype = RustBuffer
_UniFFILib.common_ad00_simulate_blocking.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_simulate_blocking.restype = ctypes.c_uint64
_UniFFILib.common_ad00_broadcast_tx_sync_blocking.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_broadcast_tx_sync_blocking.restype = RustBuffer
_UniFFILib.common_ad00_construct_unsigned_eth_tx.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_construct_unsigned_eth_tx.restype = RustBuffer
_UniFFILib.common_ad00_build_signed_eth_tx.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_build_signed_eth_tx.restype = RustBuffer
_UniFFILib.common_ad00_get_eth_balance_blocking.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_get_eth_balance_blocking.restype = RustBuffer
_UniFFILib.common_ad00_get_contract_balance_blocking.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_get_contract_balance_blocking.restype = RustBuffer
_UniFFILib.common_ad00_broadcast_eth_signed_raw_tx_blocking.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_broadcast_eth_signed_raw_tx_blocking.restype = RustBuffer
_UniFFILib.common_ad00_broadcast_sign_eth_tx_blocking.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_broadcast_sign_eth_tx_blocking.restype = RustBuffer
_UniFFILib.common_ad00_broadcast_contract_approval_tx_blocking.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_broadcast_contract_approval_tx_blocking.restype = RustBuffer
_UniFFILib.common_ad00_broadcast_contract_transfer_tx_blocking.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_broadcast_contract_transfer_tx_blocking.restype = RustBuffer
_UniFFILib.common_ad00_broadcast_contract_batch_transfer_tx_blocking.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_broadcast_contract_batch_transfer_tx_blocking.restype = RustBuffer
_UniFFILib.common_ad00_bytes_to_hex.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_bytes_to_hex.restype = RustBuffer
_UniFFILib.common_ad00_eth_sign_transaction.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_eth_sign_transaction.restype = RustBuffer
_UniFFILib.common_ad00_eth_sign_transaction_with_chainid.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.common_ad00_eth_sign_transaction_with_chainid.restype = RustBuffer
_UniFFILib.ffi_common_ad00_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_rustbuffer_alloc.restype = RustBuffer
_UniFFILib.ffi_common_ad00_rustbuffer_from_bytes.argtypes = (
    ForeignBytes,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_rustbuffer_from_bytes.restype = RustBuffer
_UniFFILib.ffi_common_ad00_rustbuffer_free.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_rustbuffer_free.restype = None
_UniFFILib.ffi_common_ad00_rustbuffer_reserve.argtypes = (
    RustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_common_ad00_rustbuffer_reserve.restype = RustBuffer

# Public interface members begin here.


class FfiConverterUInt8(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU8()

    @staticmethod
    def write(value, buf):
        buf.writeU8(value)

class FfiConverterUInt32(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU32()

    @staticmethod
    def write(value, buf):
        buf.writeU32(value)

class FfiConverterUInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU64()

    @staticmethod
    def write(value, buf):
        buf.writeU64(value)

class FfiConverterInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readI64()

    @staticmethod
    def write(value, buf):
        buf.writeI64(value)

class FfiConverterBool:
    @classmethod
    def read(cls, buf):
        return cls.lift(buf.readU8())

    @classmethod
    def write(cls, value, buf):
        buf.writeU8(cls.lower(value))

    @staticmethod
    def lift(value):
        return int(value) != 0

    @staticmethod
    def lower(value):
        return 1 if value else 0

class FfiConverterString:
    @staticmethod
    def read(buf):
        size = buf.readI32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8Bytes = buf.read(size)
        return utf8Bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8Bytes = value.encode("utf-8")
        buf.writeI32(len(utf8Bytes))
        buf.write(utf8Bytes)

    @staticmethod
    def lift(buf):
        with buf.consumeWithStream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with RustBuffer.allocWithBuilder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class Client(object):

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_common_ad00_Client_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def new_blocking(cls, grpc_web_url):
        grpc_web_url = grpc_web_url
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeRestError,_UniFFILib.common_ad00_Client_new_blocking,
        FfiConverterString.lower(grpc_web_url))
        return cls._make_instance_(pointer)
    

    def supply_blocking(self, denom_id,owner):
        denom_id = denom_id
        
        owner = owner
        
        return FfiConverterUInt64.lift(
            rust_call_with_error(
    FfiConverterTypeRestError,_UniFFILib.common_ad00_Client_supply_blocking,self._pointer,
        FfiConverterString.lower(denom_id),
        FfiConverterString.lower(owner))
        )
    def owner_blocking(self, denom_id,owner,pagination):
        denom_id = denom_id
        
        owner = owner
        
        pagination = (None if pagination is None else pagination)
        
        return FfiConverterOptionalTypeOwner.lift(
            rust_call_with_error(
    FfiConverterTypeRestError,_UniFFILib.common_ad00_Client_owner_blocking,self._pointer,
        FfiConverterString.lower(denom_id),
        FfiConverterString.lower(owner),
        FfiConverterOptionalTypePageRequest.lower(pagination))
        )
    def collection_blocking(self, denom_id,pagination):
        denom_id = denom_id
        
        pagination = (None if pagination is None else pagination)
        
        return FfiConverterOptionalTypeCollection.lift(
            rust_call_with_error(
    FfiConverterTypeRestError,_UniFFILib.common_ad00_Client_collection_blocking,self._pointer,
        FfiConverterString.lower(denom_id),
        FfiConverterOptionalTypePageRequest.lower(pagination))
        )
    def denom_blocking(self, denom_id):
        denom_id = denom_id
        
        return FfiConverterOptionalTypeDenom.lift(
            rust_call_with_error(
    FfiConverterTypeRestError,_UniFFILib.common_ad00_Client_denom_blocking,self._pointer,
        FfiConverterString.lower(denom_id))
        )
    def denom_by_name_blocking(self, denom_name):
        denom_name = denom_name
        
        return FfiConverterOptionalTypeDenom.lift(
            rust_call_with_error(
    FfiConverterTypeRestError,_UniFFILib.common_ad00_Client_denom_by_name_blocking,self._pointer,
        FfiConverterString.lower(denom_name))
        )
    def denoms_blocking(self, pagination):
        pagination = (None if pagination is None else pagination)
        
        return FfiConverterSequenceTypeDenom.lift(
            rust_call_with_error(
    FfiConverterTypeRestError,_UniFFILib.common_ad00_Client_denoms_blocking,self._pointer,
        FfiConverterOptionalTypePageRequest.lower(pagination))
        )
    def nft_blocking(self, denom_id,token_id):
        denom_id = denom_id
        
        token_id = token_id
        
        return FfiConverterOptionalTypeBaseNft.lift(
            rust_call_with_error(
    FfiConverterTypeRestError,_UniFFILib.common_ad00_Client_nft_blocking,self._pointer,
        FfiConverterString.lower(denom_id),
        FfiConverterString.lower(token_id))
        )
    


class FfiConverterTypeClient:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Client):
            raise TypeError("Expected Client instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Client._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class CosmosParserWrapper(object):

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_common_ad00_CosmosParserWrapper_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def new_base_parser(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.common_ad00_CosmosParserWrapper_new_base_parser,)
        return cls._make_instance_(pointer)
    @classmethod
    def new_crypto_org_parser(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.common_ad00_CosmosParserWrapper_new_crypto_org_parser,)
        return cls._make_instance_(pointer)
    @classmethod
    def new_luna_classic_parser(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call(_UniFFILib.common_ad00_CosmosParserWrapper_new_luna_classic_parser,)
        return cls._make_instance_(pointer)
    

    def parse_proto_json_fee(self, json_string):
        json_string = json_string
        
        return FfiConverterTypeCosmosFee.lift(
            rust_call_with_error(
    FfiConverterTypeCosmosError,_UniFFILib.common_ad00_CosmosParserWrapper_parse_proto_json_fee,self._pointer,
        FfiConverterString.lower(json_string))
        )
    def parse_proto_json_msg(self, json_string):
        json_string = json_string
        
        return FfiConverterTypeCosmosRawMsg.lift(
            rust_call_with_error(
    FfiConverterTypeCosmosError,_UniFFILib.common_ad00_CosmosParserWrapper_parse_proto_json_msg,self._pointer,
        FfiConverterString.lower(json_string))
        )
    def parse_protobuf_auto_info(self, hex_string):
        hex_string = hex_string
        
        return FfiConverterTypeCosmosAuthInfo.lift(
            rust_call_with_error(
    FfiConverterTypeCosmosError,_UniFFILib.common_ad00_CosmosParserWrapper_parse_protobuf_auto_info,self._pointer,
        FfiConverterString.lower(hex_string))
        )
    def parse_protobuf_tx_body(self, hex_string):
        hex_string = hex_string
        
        return FfiConverterTypeCosmosTxBody.lift(
            rust_call_with_error(
    FfiConverterTypeCosmosError,_UniFFILib.common_ad00_CosmosParserWrapper_parse_protobuf_tx_body,self._pointer,
        FfiConverterString.lower(hex_string))
        )
    


class FfiConverterTypeCosmosParserWrapper:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, CosmosParserWrapper):
            raise TypeError("Expected CosmosParserWrapper instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return CosmosParserWrapper._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class CosmosSdkClient(object):
    def __init__(self, tendermint_rpc_url,rest_api_url,balance_api_version,grpc_url):
        tendermint_rpc_url = tendermint_rpc_url
        
        rest_api_url = rest_api_url
        
        balance_api_version = balance_api_version
        
        grpc_url = grpc_url
        
        self._pointer = rust_call(_UniFFILib.common_ad00_CosmosSDKClient_new,
        FfiConverterString.lower(tendermint_rpc_url),
        FfiConverterString.lower(rest_api_url),
        FfiConverterTypeBalanceApiVersion.lower(balance_api_version),
        FfiConverterString.lower(grpc_url))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_common_ad00_CosmosSDKClient_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def broadcast_tx(self, raw_signed_tx,mode):
        raw_signed_tx = list(int(x) for x in raw_signed_tx)
        
        mode = (None if mode is None else mode)
        
        return FfiConverterTypeTxBroadcastResult.lift(
            rust_call_with_error(
    FfiConverterTypeRestError,_UniFFILib.common_ad00_CosmosSDKClient_broadcast_tx,self._pointer,
        FfiConverterSequenceUInt8.lower(raw_signed_tx),
        FfiConverterOptionalTypeTxBroadcastMode.lower(mode))
        )
    def get_account_balance(self, address,denom):
        address = address
        
        denom = denom
        
        return FfiConverterTypeRawRpcBalance.lift(
            rust_call_with_error(
    FfiConverterTypeRestError,_UniFFILib.common_ad00_CosmosSDKClient_get_account_balance,self._pointer,
        FfiConverterString.lower(address),
        FfiConverterString.lower(denom))
        )
    def get_account_details(self, address):
        address = address
        
        return FfiConverterTypeRawRpcAccountResponse.lift(
            rust_call_with_error(
    FfiConverterTypeRestError,_UniFFILib.common_ad00_CosmosSDKClient_get_account_details,self._pointer,
        FfiConverterString.lower(address))
        )
    def get_denom_metadata(self, denom):
        denom = denom
        
        return FfiConverterTypeDenomMetadata.lift(
            rust_call_with_error(
    FfiConverterTypeRestError,_UniFFILib.common_ad00_CosmosSDKClient_get_denom_metadata,self._pointer,
        FfiConverterString.lower(denom))
        )
    def simulate(self, raw_signed_tx):
        raw_signed_tx = list(int(x) for x in raw_signed_tx)
        
        return FfiConverterUInt64.lift(
            rust_call_with_error(
    FfiConverterTypeRestError,_UniFFILib.common_ad00_CosmosSDKClient_simulate,self._pointer,
        FfiConverterSequenceUInt8.lower(raw_signed_tx))
        )
    


class FfiConverterTypeCosmosSdkClient:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, CosmosSdkClient):
            raise TypeError("Expected CosmosSdkClient instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return CosmosSdkClient._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class CosmosSigner(object):
    def __init__(self, secret_key):
        secret_key = secret_key
        
        self._pointer = rust_call(_UniFFILib.common_ad00_CosmosSigner_new,
        FfiConverterTypeSecretKey.lower(secret_key))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_common_ad00_CosmosSigner_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def sign_direct(self, chain_id,account_number,auth_info_bytes,body_bytes):
        chain_id = chain_id
        
        account_number = account_number
        
        auth_info_bytes = auth_info_bytes
        
        body_bytes = body_bytes
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeCosmosError,_UniFFILib.common_ad00_CosmosSigner_sign_direct,self._pointer,
        FfiConverterString.lower(chain_id),
        FfiConverterString.lower(account_number),
        FfiConverterString.lower(auth_info_bytes),
        FfiConverterString.lower(body_bytes))
        )
    


class FfiConverterTypeCosmosSigner:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, CosmosSigner):
            raise TypeError("Expected CosmosSigner instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return CosmosSigner._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class EthAbiContract(object):
    def __init__(self, abi):
        abi = abi
        
        self._pointer = rust_call_with_error(FfiConverterTypeEthError,_UniFFILib.common_ad00_EthAbiContract_new,
        FfiConverterString.lower(abi))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_common_ad00_EthAbiContract_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def encode_bind(self, function_name,tokens):
        function_name = function_name
        
        tokens = list(x for x in tokens)
        
        return FfiConverterSequenceUInt8.lift(
            rust_call_with_error(
    FfiConverterTypeEthError,_UniFFILib.common_ad00_EthAbiContract_encode_bind,self._pointer,
        FfiConverterString.lower(function_name),
        FfiConverterSequenceTypeEthAbiTokenBind.lower(tokens))
        )
    


class FfiConverterTypeEthAbiContract:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, EthAbiContract):
            raise TypeError("Expected EthAbiContract instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return EthAbiContract._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class EthSigner(object):
    def __init__(self, secret_key):
        secret_key = secret_key
        
        self._pointer = rust_call(_UniFFILib.common_ad00_EthSigner_new,
        FfiConverterTypeSecretKey.lower(secret_key))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_common_ad00_EthSigner_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def eth_sign_insecure(self, hash):
        hash = hash
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeEthError,_UniFFILib.common_ad00_EthSigner_eth_sign_insecure,self._pointer,
        FfiConverterString.lower(hash))
        )
    def personal_sign(self, message):
        message = message
        
        return FfiConverterString.lift(
            rust_call(_UniFFILib.common_ad00_EthSigner_personal_sign,self._pointer,
        FfiConverterString.lower(message))
        )
    def sign_typed_data(self, json_typed_data):
        json_typed_data = json_typed_data
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeEthError,_UniFFILib.common_ad00_EthSigner_sign_typed_data,self._pointer,
        FfiConverterString.lower(json_typed_data))
        )
    


class FfiConverterTypeEthSigner:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, EthSigner):
            raise TypeError("Expected EthSigner instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return EthSigner._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class HdWallet(object):
    def __init__(self, seed_val):
        seed_val = list(int(x) for x in seed_val)
        
        self._pointer = rust_call_with_error(FfiConverterTypeHdWrapError,_UniFFILib.common_ad00_HDWallet_new,
        FfiConverterSequenceUInt8.lower(seed_val))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_common_ad00_HDWallet_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def recover_wallet(cls, mnemonic_phrase,password):
        mnemonic_phrase = mnemonic_phrase
        
        password = (None if password is None else password)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeHdWrapError,_UniFFILib.common_ad00_HDWallet_recover_wallet,
        FfiConverterString.lower(mnemonic_phrase),
        FfiConverterOptionalString.lower(password))
        return cls._make_instance_(pointer)
    @classmethod
    def generate_wallet(cls, password,word_count):
        password = (None if password is None else password)
        
        word_count = (None if word_count is None else word_count)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeHdWrapError,_UniFFILib.common_ad00_HDWallet_generate_wallet,
        FfiConverterOptionalString.lower(password),
        FfiConverterOptionalTypeMnemonicWordCount.lower(word_count))
        return cls._make_instance_(pointer)
    

    def get_backup_mnemonic_phrase(self, ):
        return FfiConverterOptionalString.lift(
            rust_call(_UniFFILib.common_ad00_HDWallet_get_backup_mnemonic_phrase,self._pointer,)
        )
    def get_default_address(self, coin):
        coin = coin
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeHdWrapError,_UniFFILib.common_ad00_HDWallet_get_default_address,self._pointer,
        FfiConverterTypeWalletCoin.lower(coin))
        )
    def get_address(self, coin,index):
        coin = coin
        
        index = int(index)
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeHdWrapError,_UniFFILib.common_ad00_HDWallet_get_address,self._pointer,
        FfiConverterTypeWalletCoin.lower(coin),
        FfiConverterUInt32.lower(index))
        )
    def get_key(self, derivation_path):
        derivation_path = derivation_path
        
        return FfiConverterTypeSecretKey.lift(
            rust_call_with_error(
    FfiConverterTypeHdWrapError,_UniFFILib.common_ad00_HDWallet_get_key,self._pointer,
        FfiConverterString.lower(derivation_path))
        )
    def get_key_from_index(self, coin,index):
        coin = coin
        
        index = int(index)
        
        return FfiConverterTypeSecretKey.lift(
            rust_call_with_error(
    FfiConverterTypeHdWrapError,_UniFFILib.common_ad00_HDWallet_get_key_from_index,self._pointer,
        FfiConverterTypeWalletCoin.lower(coin),
        FfiConverterUInt32.lower(index))
        )
    


class FfiConverterTypeHdWallet:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, HdWallet):
            raise TypeError("Expected HdWallet instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return HdWallet._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class SecretKey(object):
    def __init__(self, ):
        self._pointer = rust_call(_UniFFILib.common_ad00_SecretKey_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_common_ad00_SecretKey_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_bytes(cls, bytes):
        bytes = list(int(x) for x in bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeSecretKeyWrapError,_UniFFILib.common_ad00_SecretKey_from_bytes,
        FfiConverterSequenceUInt8.lower(bytes))
        return cls._make_instance_(pointer)
    @classmethod
    def from_hex(cls, hex):
        hex = hex
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeSecretKeyWrapError,_UniFFILib.common_ad00_SecretKey_from_hex,
        FfiConverterString.lower(hex))
        return cls._make_instance_(pointer)
    

    def get_public_key_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.common_ad00_SecretKey_get_public_key_bytes,self._pointer,)
        )
    def get_public_key_hex(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.common_ad00_SecretKey_get_public_key_hex,self._pointer,)
        )
    def to_bytes(self, ):
        return FfiConverterSequenceUInt8.lift(
            rust_call(_UniFFILib.common_ad00_SecretKey_to_bytes,self._pointer,)
        )
    def to_hex(self, ):
        return FfiConverterString.lift(
            rust_call(_UniFFILib.common_ad00_SecretKey_to_hex,self._pointer,)
        )
    def to_address(self, coin):
        coin = coin
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeHdWrapError,_UniFFILib.common_ad00_SecretKey_to_address,self._pointer,
        FfiConverterTypeWalletCoin.lower(coin))
        )
    


class FfiConverterTypeSecretKey:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, SecretKey):
            raise TypeError("Expected SecretKey instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return SecretKey._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class WalletCoinFunc(object):
    def __init__(self, coin):
        coin = coin
        
        self._pointer = rust_call(_UniFFILib.common_ad00_WalletCoinFunc_new,
        FfiConverterTypeWalletCoin.lower(coin))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_common_ad00_WalletCoinFunc_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def derive_address(self, private_key):
        private_key = private_key
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeHdWrapError,_UniFFILib.common_ad00_WalletCoinFunc_derive_address,self._pointer,
        FfiConverterTypeSecretKey.lower(private_key))
        )
    def get_coin_type(self, ):
        return FfiConverterUInt32.lift(
            rust_call(_UniFFILib.common_ad00_WalletCoinFunc_get_coin_type,self._pointer,)
        )
    def get_eth_network(self, ):
        return FfiConverterTypeEthNetwork.lift(
            rust_call(_UniFFILib.common_ad00_WalletCoinFunc_get_eth_network,self._pointer,)
        )
    


class FfiConverterTypeWalletCoinFunc:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, WalletCoinFunc):
            raise TypeError("Expected WalletCoinFunc instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return WalletCoinFunc._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class BaseNft:

    def __init__(self, id, name, uri, data, owner):
        self.id = id
        self.name = name
        self.uri = uri
        self.data = data
        self.owner = owner

    def __str__(self):
        return "BaseNft(id={}, name={}, uri={}, data={}, owner={})".format(self.id, self.name, self.uri, self.data, self.owner)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.uri != other.uri:
            return False
        if self.data != other.data:
            return False
        if self.owner != other.owner:
            return False
        return True

class FfiConverterTypeBaseNft(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BaseNft(
            id=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
            uri=FfiConverterString.read(buf),
            data=FfiConverterString.read(buf),
            owner=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.id, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterString.write(value.uri, buf)
        FfiConverterString.write(value.data, buf)
        FfiConverterString.write(value.owner, buf)


class Collection:

    def __init__(self, denom, nfts):
        self.denom = denom
        self.nfts = nfts

    def __str__(self):
        return "Collection(denom={}, nfts={})".format(self.denom, self.nfts)

    def __eq__(self, other):
        if self.denom != other.denom:
            return False
        if self.nfts != other.nfts:
            return False
        return True

class FfiConverterTypeCollection(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Collection(
            denom=FfiConverterOptionalTypeDenom.read(buf),
            nfts=FfiConverterSequenceTypeBaseNft.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalTypeDenom.write(value.denom, buf)
        FfiConverterSequenceTypeBaseNft.write(value.nfts, buf)


class CosmosAny:

    def __init__(self, type_url, value):
        self.type_url = type_url
        self.value = value

    def __str__(self):
        return "CosmosAny(type_url={}, value={})".format(self.type_url, self.value)

    def __eq__(self, other):
        if self.type_url != other.type_url:
            return False
        if self.value != other.value:
            return False
        return True

class FfiConverterTypeCosmosAny(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CosmosAny(
            type_url=FfiConverterString.read(buf),
            value=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.type_url, buf)
        FfiConverterString.write(value.value, buf)


class CosmosAuthInfo:

    def __init__(self, fee, signer_infos):
        self.fee = fee
        self.signer_infos = signer_infos

    def __str__(self):
        return "CosmosAuthInfo(fee={}, signer_infos={})".format(self.fee, self.signer_infos)

    def __eq__(self, other):
        if self.fee != other.fee:
            return False
        if self.signer_infos != other.signer_infos:
            return False
        return True

class FfiConverterTypeCosmosAuthInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CosmosAuthInfo(
            fee=FfiConverterTypeCosmosFee.read(buf),
            signer_infos=FfiConverterSequenceTypeCosmosSignerInfo.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeCosmosFee.write(value.fee, buf)
        FfiConverterSequenceTypeCosmosSignerInfo.write(value.signer_infos, buf)


class CosmosFee:

    def __init__(self, amount, gas_limit, payer, granter):
        self.amount = amount
        self.gas_limit = gas_limit
        self.payer = payer
        self.granter = granter

    def __str__(self):
        return "CosmosFee(amount={}, gas_limit={}, payer={}, granter={})".format(self.amount, self.gas_limit, self.payer, self.granter)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        if self.gas_limit != other.gas_limit:
            return False
        if self.payer != other.payer:
            return False
        if self.granter != other.granter:
            return False
        return True

class FfiConverterTypeCosmosFee(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CosmosFee(
            amount=FfiConverterSequenceTypeSingleCoin.read(buf),
            gas_limit=FfiConverterUInt64.read(buf),
            payer=FfiConverterOptionalString.read(buf),
            granter=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceTypeSingleCoin.write(value.amount, buf)
        FfiConverterUInt64.write(value.gas_limit, buf)
        FfiConverterOptionalString.write(value.payer, buf)
        FfiConverterOptionalString.write(value.granter, buf)


class CosmosLegacyAminoMultisig:

    def __init__(self, threshold, public_keys):
        self.threshold = threshold
        self.public_keys = public_keys

    def __str__(self):
        return "CosmosLegacyAminoMultisig(threshold={}, public_keys={})".format(self.threshold, self.public_keys)

    def __eq__(self, other):
        if self.threshold != other.threshold:
            return False
        if self.public_keys != other.public_keys:
            return False
        return True

class FfiConverterTypeCosmosLegacyAminoMultisig(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CosmosLegacyAminoMultisig(
            threshold=FfiConverterUInt32.read(buf),
            public_keys=FfiConverterSequenceTypeCosmosAny.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt32.write(value.threshold, buf)
        FfiConverterSequenceTypeCosmosAny.write(value.public_keys, buf)


class CosmosSdkTxInfo:

    def __init__(self, account_number, sequence_number, gas_limit, fee_amount, timeout_height, memo_note, network):
        self.account_number = account_number
        self.sequence_number = sequence_number
        self.gas_limit = gas_limit
        self.fee_amount = fee_amount
        self.timeout_height = timeout_height
        self.memo_note = memo_note
        self.network = network

    def __str__(self):
        return "CosmosSdkTxInfo(account_number={}, sequence_number={}, gas_limit={}, fee_amount={}, timeout_height={}, memo_note={}, network={})".format(self.account_number, self.sequence_number, self.gas_limit, self.fee_amount, self.timeout_height, self.memo_note, self.network)

    def __eq__(self, other):
        if self.account_number != other.account_number:
            return False
        if self.sequence_number != other.sequence_number:
            return False
        if self.gas_limit != other.gas_limit:
            return False
        if self.fee_amount != other.fee_amount:
            return False
        if self.timeout_height != other.timeout_height:
            return False
        if self.memo_note != other.memo_note:
            return False
        if self.network != other.network:
            return False
        return True

class FfiConverterTypeCosmosSdkTxInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CosmosSdkTxInfo(
            account_number=FfiConverterUInt64.read(buf),
            sequence_number=FfiConverterUInt64.read(buf),
            gas_limit=FfiConverterUInt64.read(buf),
            fee_amount=FfiConverterTypeSingleCoin.read(buf),
            timeout_height=FfiConverterUInt32.read(buf),
            memo_note=FfiConverterOptionalString.read(buf),
            network=FfiConverterTypeNetwork.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.account_number, buf)
        FfiConverterUInt64.write(value.sequence_number, buf)
        FfiConverterUInt64.write(value.gas_limit, buf)
        FfiConverterTypeSingleCoin.write(value.fee_amount, buf)
        FfiConverterUInt32.write(value.timeout_height, buf)
        FfiConverterOptionalString.write(value.memo_note, buf)
        FfiConverterTypeNetwork.write(value.network, buf)


class CosmosSignerInfo:

    def __init__(self, public_key, mode_info, sequence):
        self.public_key = public_key
        self.mode_info = mode_info
        self.sequence = sequence

    def __str__(self):
        return "CosmosSignerInfo(public_key={}, mode_info={}, sequence={})".format(self.public_key, self.mode_info, self.sequence)

    def __eq__(self, other):
        if self.public_key != other.public_key:
            return False
        if self.mode_info != other.mode_info:
            return False
        if self.sequence != other.sequence:
            return False
        return True

class FfiConverterTypeCosmosSignerInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CosmosSignerInfo(
            public_key=FfiConverterOptionalTypeCosmosSignerPublicKey.read(buf),
            mode_info=FfiConverterTypeCosmosModeInfo.read(buf),
            sequence=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalTypeCosmosSignerPublicKey.write(value.public_key, buf)
        FfiConverterTypeCosmosModeInfo.write(value.mode_info, buf)
        FfiConverterUInt64.write(value.sequence, buf)


class CosmosTxBody:

    def __init__(self, messages, memo, timeout_height, extension_options, non_critical_extension_options):
        self.messages = messages
        self.memo = memo
        self.timeout_height = timeout_height
        self.extension_options = extension_options
        self.non_critical_extension_options = non_critical_extension_options

    def __str__(self):
        return "CosmosTxBody(messages={}, memo={}, timeout_height={}, extension_options={}, non_critical_extension_options={})".format(self.messages, self.memo, self.timeout_height, self.extension_options, self.non_critical_extension_options)

    def __eq__(self, other):
        if self.messages != other.messages:
            return False
        if self.memo != other.memo:
            return False
        if self.timeout_height != other.timeout_height:
            return False
        if self.extension_options != other.extension_options:
            return False
        if self.non_critical_extension_options != other.non_critical_extension_options:
            return False
        return True

class FfiConverterTypeCosmosTxBody(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CosmosTxBody(
            messages=FfiConverterSequenceTypeCosmosRawMsg.read(buf),
            memo=FfiConverterString.read(buf),
            timeout_height=FfiConverterUInt64.read(buf),
            extension_options=FfiConverterSequenceTypeCosmosAny.read(buf),
            non_critical_extension_options=FfiConverterSequenceTypeCosmosAny.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceTypeCosmosRawMsg.write(value.messages, buf)
        FfiConverterString.write(value.memo, buf)
        FfiConverterUInt64.write(value.timeout_height, buf)
        FfiConverterSequenceTypeCosmosAny.write(value.extension_options, buf)
        FfiConverterSequenceTypeCosmosAny.write(value.non_critical_extension_options, buf)


class Denom:

    def __init__(self, id, name, schema, creator):
        self.id = id
        self.name = name
        self.schema = schema
        self.creator = creator

    def __str__(self):
        return "Denom(id={}, name={}, schema={}, creator={})".format(self.id, self.name, self.schema, self.creator)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.name != other.name:
            return False
        if self.schema != other.schema:
            return False
        if self.creator != other.creator:
            return False
        return True

class FfiConverterTypeDenom(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Denom(
            id=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
            schema=FfiConverterString.read(buf),
            creator=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.id, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterString.write(value.schema, buf)
        FfiConverterString.write(value.creator, buf)


class DenomMetadata:

    def __init__(self, base, name, description, display, symbol, denom_units):
        self.base = base
        self.name = name
        self.description = description
        self.display = display
        self.symbol = symbol
        self.denom_units = denom_units

    def __str__(self):
        return "DenomMetadata(base={}, name={}, description={}, display={}, symbol={}, denom_units={})".format(self.base, self.name, self.description, self.display, self.symbol, self.denom_units)

    def __eq__(self, other):
        if self.base != other.base:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.display != other.display:
            return False
        if self.symbol != other.symbol:
            return False
        if self.denom_units != other.denom_units:
            return False
        return True

class FfiConverterTypeDenomMetadata(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DenomMetadata(
            base=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
            description=FfiConverterString.read(buf),
            display=FfiConverterString.read(buf),
            symbol=FfiConverterString.read(buf),
            denom_units=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.base, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterString.write(value.description, buf)
        FfiConverterString.write(value.display, buf)
        FfiConverterString.write(value.symbol, buf)
        FfiConverterString.write(value.denom_units, buf)


class EthTxInfo:

    def __init__(self, to_address, amount, nonce, gas_limit, gas_price, data, legacy_tx):
        self.to_address = to_address
        self.amount = amount
        self.nonce = nonce
        self.gas_limit = gas_limit
        self.gas_price = gas_price
        self.data = data
        self.legacy_tx = legacy_tx

    def __str__(self):
        return "EthTxInfo(to_address={}, amount={}, nonce={}, gas_limit={}, gas_price={}, data={}, legacy_tx={})".format(self.to_address, self.amount, self.nonce, self.gas_limit, self.gas_price, self.data, self.legacy_tx)

    def __eq__(self, other):
        if self.to_address != other.to_address:
            return False
        if self.amount != other.amount:
            return False
        if self.nonce != other.nonce:
            return False
        if self.gas_limit != other.gas_limit:
            return False
        if self.gas_price != other.gas_price:
            return False
        if self.data != other.data:
            return False
        if self.legacy_tx != other.legacy_tx:
            return False
        return True

class FfiConverterTypeEthTxInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EthTxInfo(
            to_address=FfiConverterString.read(buf),
            amount=FfiConverterTypeEthAmount.read(buf),
            nonce=FfiConverterString.read(buf),
            gas_limit=FfiConverterString.read(buf),
            gas_price=FfiConverterTypeEthAmount.read(buf),
            data=FfiConverterOptionalSequenceUInt8.read(buf),
            legacy_tx=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.to_address, buf)
        FfiConverterTypeEthAmount.write(value.amount, buf)
        FfiConverterString.write(value.nonce, buf)
        FfiConverterString.write(value.gas_limit, buf)
        FfiConverterTypeEthAmount.write(value.gas_price, buf)
        FfiConverterOptionalSequenceUInt8.write(value.data, buf)
        FfiConverterBool.write(value.legacy_tx, buf)


class Height:

    def __init__(self, revision_number, revision_height):
        self.revision_number = revision_number
        self.revision_height = revision_height

    def __str__(self):
        return "Height(revision_number={}, revision_height={})".format(self.revision_number, self.revision_height)

    def __eq__(self, other):
        if self.revision_number != other.revision_number:
            return False
        if self.revision_height != other.revision_height:
            return False
        return True

class FfiConverterTypeHeight(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Height(
            revision_number=FfiConverterUInt64.read(buf),
            revision_height=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.revision_number, buf)
        FfiConverterUInt64.write(value.revision_height, buf)


class IdCollection:

    def __init__(self, denom_id, token_ids):
        self.denom_id = denom_id
        self.token_ids = token_ids

    def __str__(self):
        return "IdCollection(denom_id={}, token_ids={})".format(self.denom_id, self.token_ids)

    def __eq__(self, other):
        if self.denom_id != other.denom_id:
            return False
        if self.token_ids != other.token_ids:
            return False
        return True

class FfiConverterTypeIdCollection(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return IdCollection(
            denom_id=FfiConverterString.read(buf),
            token_ids=FfiConverterSequenceString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.denom_id, buf)
        FfiConverterSequenceString.write(value.token_ids, buf)


class Owner:

    def __init__(self, address, id_collections):
        self.address = address
        self.id_collections = id_collections

    def __str__(self):
        return "Owner(address={}, id_collections={})".format(self.address, self.id_collections)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.id_collections != other.id_collections:
            return False
        return True

class FfiConverterTypeOwner(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Owner(
            address=FfiConverterString.read(buf),
            id_collections=FfiConverterSequenceTypeIdCollection.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.address, buf)
        FfiConverterSequenceTypeIdCollection.write(value.id_collections, buf)


class PageRequest:

    def __init__(self, key, offset, limit, count_total, reverse):
        self.key = key
        self.offset = offset
        self.limit = limit
        self.count_total = count_total
        self.reverse = reverse

    def __str__(self):
        return "PageRequest(key={}, offset={}, limit={}, count_total={}, reverse={})".format(self.key, self.offset, self.limit, self.count_total, self.reverse)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.offset != other.offset:
            return False
        if self.limit != other.limit:
            return False
        if self.count_total != other.count_total:
            return False
        if self.reverse != other.reverse:
            return False
        return True

class FfiConverterTypePageRequest(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PageRequest(
            key=FfiConverterSequenceUInt8.read(buf),
            offset=FfiConverterUInt64.read(buf),
            limit=FfiConverterUInt64.read(buf),
            count_total=FfiConverterBool.read(buf),
            reverse=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceUInt8.write(value.key, buf)
        FfiConverterUInt64.write(value.offset, buf)
        FfiConverterUInt64.write(value.limit, buf)
        FfiConverterBool.write(value.count_total, buf)
        FfiConverterBool.write(value.reverse, buf)


class RawRpcAccountStatus:

    def __init__(self, account_type, address, pub_key, account_number, sequence):
        self.account_type = account_type
        self.address = address
        self.pub_key = pub_key
        self.account_number = account_number
        self.sequence = sequence

    def __str__(self):
        return "RawRpcAccountStatus(account_type={}, address={}, pub_key={}, account_number={}, sequence={})".format(self.account_type, self.address, self.pub_key, self.account_number, self.sequence)

    def __eq__(self, other):
        if self.account_type != other.account_type:
            return False
        if self.address != other.address:
            return False
        if self.pub_key != other.pub_key:
            return False
        if self.account_number != other.account_number:
            return False
        if self.sequence != other.sequence:
            return False
        return True

class FfiConverterTypeRawRpcAccountStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RawRpcAccountStatus(
            account_type=FfiConverterString.read(buf),
            address=FfiConverterString.read(buf),
            pub_key=FfiConverterOptionalTypeRawRpcPubKey.read(buf),
            account_number=FfiConverterUInt64.read(buf),
            sequence=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.account_type, buf)
        FfiConverterString.write(value.address, buf)
        FfiConverterOptionalTypeRawRpcPubKey.write(value.pub_key, buf)
        FfiConverterUInt64.write(value.account_number, buf)
        FfiConverterUInt64.write(value.sequence, buf)


class RawRpcBalance:

    def __init__(self, denom, amount):
        self.denom = denom
        self.amount = amount

    def __str__(self):
        return "RawRpcBalance(denom={}, amount={})".format(self.denom, self.amount)

    def __eq__(self, other):
        if self.denom != other.denom:
            return False
        if self.amount != other.amount:
            return False
        return True

class FfiConverterTypeRawRpcBalance(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RawRpcBalance(
            denom=FfiConverterString.read(buf),
            amount=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.denom, buf)
        FfiConverterString.write(value.amount, buf)


class RawRpcPubKey:

    def __init__(self, pub_key_type, key):
        self.pub_key_type = pub_key_type
        self.key = key

    def __str__(self):
        return "RawRpcPubKey(pub_key_type={}, key={})".format(self.pub_key_type, self.key)

    def __eq__(self, other):
        if self.pub_key_type != other.pub_key_type:
            return False
        if self.key != other.key:
            return False
        return True

class FfiConverterTypeRawRpcPubKey(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RawRpcPubKey(
            pub_key_type=FfiConverterString.read(buf),
            key=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.pub_key_type, buf)
        FfiConverterString.write(value.key, buf)


class TransactionReceipt:

    def __init__(self, transaction_hash, transaction_index, block_hash, block_number, cumulative_gas_used, gas_used, contract_address, logs, status, root, logs_bloom, transaction_type, effective_gas_price):
        self.transaction_hash = transaction_hash
        self.transaction_index = transaction_index
        self.block_hash = block_hash
        self.block_number = block_number
        self.cumulative_gas_used = cumulative_gas_used
        self.gas_used = gas_used
        self.contract_address = contract_address
        self.logs = logs
        self.status = status
        self.root = root
        self.logs_bloom = logs_bloom
        self.transaction_type = transaction_type
        self.effective_gas_price = effective_gas_price

    def __str__(self):
        return "TransactionReceipt(transaction_hash={}, transaction_index={}, block_hash={}, block_number={}, cumulative_gas_used={}, gas_used={}, contract_address={}, logs={}, status={}, root={}, logs_bloom={}, transaction_type={}, effective_gas_price={})".format(self.transaction_hash, self.transaction_index, self.block_hash, self.block_number, self.cumulative_gas_used, self.gas_used, self.contract_address, self.logs, self.status, self.root, self.logs_bloom, self.transaction_type, self.effective_gas_price)

    def __eq__(self, other):
        if self.transaction_hash != other.transaction_hash:
            return False
        if self.transaction_index != other.transaction_index:
            return False
        if self.block_hash != other.block_hash:
            return False
        if self.block_number != other.block_number:
            return False
        if self.cumulative_gas_used != other.cumulative_gas_used:
            return False
        if self.gas_used != other.gas_used:
            return False
        if self.contract_address != other.contract_address:
            return False
        if self.logs != other.logs:
            return False
        if self.status != other.status:
            return False
        if self.root != other.root:
            return False
        if self.logs_bloom != other.logs_bloom:
            return False
        if self.transaction_type != other.transaction_type:
            return False
        if self.effective_gas_price != other.effective_gas_price:
            return False
        return True

class FfiConverterTypeTransactionReceipt(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionReceipt(
            transaction_hash=FfiConverterSequenceUInt8.read(buf),
            transaction_index=FfiConverterString.read(buf),
            block_hash=FfiConverterSequenceUInt8.read(buf),
            block_number=FfiConverterString.read(buf),
            cumulative_gas_used=FfiConverterString.read(buf),
            gas_used=FfiConverterString.read(buf),
            contract_address=FfiConverterString.read(buf),
            logs=FfiConverterSequenceString.read(buf),
            status=FfiConverterString.read(buf),
            root=FfiConverterSequenceUInt8.read(buf),
            logs_bloom=FfiConverterSequenceUInt8.read(buf),
            transaction_type=FfiConverterString.read(buf),
            effective_gas_price=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterSequenceUInt8.write(value.transaction_hash, buf)
        FfiConverterString.write(value.transaction_index, buf)
        FfiConverterSequenceUInt8.write(value.block_hash, buf)
        FfiConverterString.write(value.block_number, buf)
        FfiConverterString.write(value.cumulative_gas_used, buf)
        FfiConverterString.write(value.gas_used, buf)
        FfiConverterString.write(value.contract_address, buf)
        FfiConverterSequenceString.write(value.logs, buf)
        FfiConverterString.write(value.status, buf)
        FfiConverterSequenceUInt8.write(value.root, buf)
        FfiConverterSequenceUInt8.write(value.logs_bloom, buf)
        FfiConverterString.write(value.transaction_type, buf)
        FfiConverterString.write(value.effective_gas_price, buf)


class TxBroadcastResult:

    def __init__(self, tx_hash_hex, code, log):
        self.tx_hash_hex = tx_hash_hex
        self.code = code
        self.log = log

    def __str__(self):
        return "TxBroadcastResult(tx_hash_hex={}, code={}, log={})".format(self.tx_hash_hex, self.code, self.log)

    def __eq__(self, other):
        if self.tx_hash_hex != other.tx_hash_hex:
            return False
        if self.code != other.code:
            return False
        if self.log != other.log:
            return False
        return True

class FfiConverterTypeTxBroadcastResult(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxBroadcastResult(
            tx_hash_hex=FfiConverterString.read(buf),
            code=FfiConverterUInt32.read(buf),
            log=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.tx_hash_hex, buf)
        FfiConverterUInt32.write(value.code, buf)
        FfiConverterString.write(value.log, buf)




class BalanceApiVersion(enum.Enum):
    OLD = 1
    NEW = 2
    


class FfiConverterTypeBalanceApiVersion(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return BalanceApiVersion.OLD
        if variant == 2:
            return BalanceApiVersion.NEW
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == BalanceApiVersion.OLD:
            buf.writeI32(1)
        if value == BalanceApiVersion.NEW:
            buf.writeI32(2)




class ContractApproval:
    def __init__(self):
        raise RuntimeError("ContractApproval cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ERC20(object):
        def __init__(self,contract_address, approved_address, amount):
            
            self.contract_address = contract_address
            self.approved_address = approved_address
            self.amount = amount
            

        def __str__(self):
            return "ContractApproval.ERC20(contract_address={}, approved_address={}, amount={})".format(self.contract_address, self.approved_address, self.amount)

        def __eq__(self, other):
            if not other.is_erc20():
                return False
            if self.contract_address != other.contract_address:
                return False
            if self.approved_address != other.approved_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class ERC721_APPROVE(object):
        def __init__(self,contract_address, approved_address, token_id):
            
            self.contract_address = contract_address
            self.approved_address = approved_address
            self.token_id = token_id
            

        def __str__(self):
            return "ContractApproval.ERC721_APPROVE(contract_address={}, approved_address={}, token_id={})".format(self.contract_address, self.approved_address, self.token_id)

        def __eq__(self, other):
            if not other.is_erc721_approve():
                return False
            if self.contract_address != other.contract_address:
                return False
            if self.approved_address != other.approved_address:
                return False
            if self.token_id != other.token_id:
                return False
            return True
    class ERC721_SET_APPROVAL_FOR_ALL(object):
        def __init__(self,contract_address, approved_address, approved):
            
            self.contract_address = contract_address
            self.approved_address = approved_address
            self.approved = approved
            

        def __str__(self):
            return "ContractApproval.ERC721_SET_APPROVAL_FOR_ALL(contract_address={}, approved_address={}, approved={})".format(self.contract_address, self.approved_address, self.approved)

        def __eq__(self, other):
            if not other.is_erc721_set_approval_for_all():
                return False
            if self.contract_address != other.contract_address:
                return False
            if self.approved_address != other.approved_address:
                return False
            if self.approved != other.approved:
                return False
            return True
    class ERC1155(object):
        def __init__(self,contract_address, approved_address, approved):
            
            self.contract_address = contract_address
            self.approved_address = approved_address
            self.approved = approved
            

        def __str__(self):
            return "ContractApproval.ERC1155(contract_address={}, approved_address={}, approved={})".format(self.contract_address, self.approved_address, self.approved)

        def __eq__(self, other):
            if not other.is_erc1155():
                return False
            if self.contract_address != other.contract_address:
                return False
            if self.approved_address != other.approved_address:
                return False
            if self.approved != other.approved:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_erc20(self):
        return isinstance(self, ContractApproval.ERC20)
    def is_erc721_approve(self):
        return isinstance(self, ContractApproval.ERC721_APPROVE)
    def is_erc721_set_approval_for_all(self):
        return isinstance(self, ContractApproval.ERC721_SET_APPROVAL_FOR_ALL)
    def is_erc1155(self):
        return isinstance(self, ContractApproval.ERC1155)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ContractApproval.ERC20 = type("ContractApproval.ERC20", (ContractApproval.ERC20, ContractApproval,), {})
ContractApproval.ERC721_APPROVE = type("ContractApproval.ERC721_APPROVE", (ContractApproval.ERC721_APPROVE, ContractApproval,), {})
ContractApproval.ERC721_SET_APPROVAL_FOR_ALL = type("ContractApproval.ERC721_SET_APPROVAL_FOR_ALL", (ContractApproval.ERC721_SET_APPROVAL_FOR_ALL, ContractApproval,), {})
ContractApproval.ERC1155 = type("ContractApproval.ERC1155", (ContractApproval.ERC1155, ContractApproval,), {})




class FfiConverterTypeContractApproval(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ContractApproval.ERC20(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return ContractApproval.ERC721_APPROVE(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return ContractApproval.ERC721_SET_APPROVAL_FOR_ALL(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterBool.read(buf),
            )
        if variant == 4:
            return ContractApproval.ERC1155(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterBool.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_erc20():
            buf.writeI32(1)
            FfiConverterString.write(value.contract_address, buf)
            FfiConverterString.write(value.approved_address, buf)
            FfiConverterString.write(value.amount, buf)
        if value.is_erc721_approve():
            buf.writeI32(2)
            FfiConverterString.write(value.contract_address, buf)
            FfiConverterString.write(value.approved_address, buf)
            FfiConverterString.write(value.token_id, buf)
        if value.is_erc721_set_approval_for_all():
            buf.writeI32(3)
            FfiConverterString.write(value.contract_address, buf)
            FfiConverterString.write(value.approved_address, buf)
            FfiConverterBool.write(value.approved, buf)
        if value.is_erc1155():
            buf.writeI32(4)
            FfiConverterString.write(value.contract_address, buf)
            FfiConverterString.write(value.approved_address, buf)
            FfiConverterBool.write(value.approved, buf)




class ContractBalance:
    def __init__(self):
        raise RuntimeError("ContractBalance cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ERC20(object):
        def __init__(self,contract_address):
            
            self.contract_address = contract_address
            

        def __str__(self):
            return "ContractBalance.ERC20(contract_address={})".format(self.contract_address)

        def __eq__(self, other):
            if not other.is_erc20():
                return False
            if self.contract_address != other.contract_address:
                return False
            return True
    class ERC721(object):
        def __init__(self,contract_address):
            
            self.contract_address = contract_address
            

        def __str__(self):
            return "ContractBalance.ERC721(contract_address={})".format(self.contract_address)

        def __eq__(self, other):
            if not other.is_erc721():
                return False
            if self.contract_address != other.contract_address:
                return False
            return True
    class ERC1155(object):
        def __init__(self,contract_address, token_id):
            
            self.contract_address = contract_address
            self.token_id = token_id
            

        def __str__(self):
            return "ContractBalance.ERC1155(contract_address={}, token_id={})".format(self.contract_address, self.token_id)

        def __eq__(self, other):
            if not other.is_erc1155():
                return False
            if self.contract_address != other.contract_address:
                return False
            if self.token_id != other.token_id:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_erc20(self):
        return isinstance(self, ContractBalance.ERC20)
    def is_erc721(self):
        return isinstance(self, ContractBalance.ERC721)
    def is_erc1155(self):
        return isinstance(self, ContractBalance.ERC1155)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ContractBalance.ERC20 = type("ContractBalance.ERC20", (ContractBalance.ERC20, ContractBalance,), {})
ContractBalance.ERC721 = type("ContractBalance.ERC721", (ContractBalance.ERC721, ContractBalance,), {})
ContractBalance.ERC1155 = type("ContractBalance.ERC1155", (ContractBalance.ERC1155, ContractBalance,), {})




class FfiConverterTypeContractBalance(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ContractBalance.ERC20(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return ContractBalance.ERC721(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return ContractBalance.ERC1155(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_erc20():
            buf.writeI32(1)
            FfiConverterString.write(value.contract_address, buf)
        if value.is_erc721():
            buf.writeI32(2)
            FfiConverterString.write(value.contract_address, buf)
        if value.is_erc1155():
            buf.writeI32(3)
            FfiConverterString.write(value.contract_address, buf)
            FfiConverterString.write(value.token_id, buf)




class ContractBatchTransfer:
    def __init__(self):
        raise RuntimeError("ContractBatchTransfer cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ERC1155(object):
        def __init__(self,contract_address, from_address, to_address, token_ids, amounts, additional_data):
            
            self.contract_address = contract_address
            self.from_address = from_address
            self.to_address = to_address
            self.token_ids = token_ids
            self.amounts = amounts
            self.additional_data = additional_data
            

        def __str__(self):
            return "ContractBatchTransfer.ERC1155(contract_address={}, from_address={}, to_address={}, token_ids={}, amounts={}, additional_data={})".format(self.contract_address, self.from_address, self.to_address, self.token_ids, self.amounts, self.additional_data)

        def __eq__(self, other):
            if not other.is_erc1155():
                return False
            if self.contract_address != other.contract_address:
                return False
            if self.from_address != other.from_address:
                return False
            if self.to_address != other.to_address:
                return False
            if self.token_ids != other.token_ids:
                return False
            if self.amounts != other.amounts:
                return False
            if self.additional_data != other.additional_data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_erc1155(self):
        return isinstance(self, ContractBatchTransfer.ERC1155)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ContractBatchTransfer.ERC1155 = type("ContractBatchTransfer.ERC1155", (ContractBatchTransfer.ERC1155, ContractBatchTransfer,), {})




class FfiConverterTypeContractBatchTransfer(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ContractBatchTransfer.ERC1155(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterSequenceString.read(buf),
                FfiConverterSequenceString.read(buf),
                FfiConverterSequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_erc1155():
            buf.writeI32(1)
            FfiConverterString.write(value.contract_address, buf)
            FfiConverterString.write(value.from_address, buf)
            FfiConverterString.write(value.to_address, buf)
            FfiConverterSequenceString.write(value.token_ids, buf)
            FfiConverterSequenceString.write(value.amounts, buf)
            FfiConverterSequenceUInt8.write(value.additional_data, buf)




class ContractTransfer:
    def __init__(self):
        raise RuntimeError("ContractTransfer cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ERC20_TRANSFER(object):
        def __init__(self,contract_address, to_address, amount):
            
            self.contract_address = contract_address
            self.to_address = to_address
            self.amount = amount
            

        def __str__(self):
            return "ContractTransfer.ERC20_TRANSFER(contract_address={}, to_address={}, amount={})".format(self.contract_address, self.to_address, self.amount)

        def __eq__(self, other):
            if not other.is_erc20_transfer():
                return False
            if self.contract_address != other.contract_address:
                return False
            if self.to_address != other.to_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class ERC20_TRANSFER_FROM(object):
        def __init__(self,contract_address, from_address, to_address, amount):
            
            self.contract_address = contract_address
            self.from_address = from_address
            self.to_address = to_address
            self.amount = amount
            

        def __str__(self):
            return "ContractTransfer.ERC20_TRANSFER_FROM(contract_address={}, from_address={}, to_address={}, amount={})".format(self.contract_address, self.from_address, self.to_address, self.amount)

        def __eq__(self, other):
            if not other.is_erc20_transfer_from():
                return False
            if self.contract_address != other.contract_address:
                return False
            if self.from_address != other.from_address:
                return False
            if self.to_address != other.to_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class ERC721_TRANSFER_FROM(object):
        def __init__(self,contract_address, from_address, to_address, token_id):
            
            self.contract_address = contract_address
            self.from_address = from_address
            self.to_address = to_address
            self.token_id = token_id
            

        def __str__(self):
            return "ContractTransfer.ERC721_TRANSFER_FROM(contract_address={}, from_address={}, to_address={}, token_id={})".format(self.contract_address, self.from_address, self.to_address, self.token_id)

        def __eq__(self, other):
            if not other.is_erc721_transfer_from():
                return False
            if self.contract_address != other.contract_address:
                return False
            if self.from_address != other.from_address:
                return False
            if self.to_address != other.to_address:
                return False
            if self.token_id != other.token_id:
                return False
            return True
    class ERC721_SAFE_TRANSFER_FROM(object):
        def __init__(self,contract_address, from_address, to_address, token_id):
            
            self.contract_address = contract_address
            self.from_address = from_address
            self.to_address = to_address
            self.token_id = token_id
            

        def __str__(self):
            return "ContractTransfer.ERC721_SAFE_TRANSFER_FROM(contract_address={}, from_address={}, to_address={}, token_id={})".format(self.contract_address, self.from_address, self.to_address, self.token_id)

        def __eq__(self, other):
            if not other.is_erc721_safe_transfer_from():
                return False
            if self.contract_address != other.contract_address:
                return False
            if self.from_address != other.from_address:
                return False
            if self.to_address != other.to_address:
                return False
            if self.token_id != other.token_id:
                return False
            return True
    class ERC721_SAFE_TRANSFER_FROM_WITH_ADDITIONAL_DATA(object):
        def __init__(self,contract_address, from_address, to_address, token_id, additional_data):
            
            self.contract_address = contract_address
            self.from_address = from_address
            self.to_address = to_address
            self.token_id = token_id
            self.additional_data = additional_data
            

        def __str__(self):
            return "ContractTransfer.ERC721_SAFE_TRANSFER_FROM_WITH_ADDITIONAL_DATA(contract_address={}, from_address={}, to_address={}, token_id={}, additional_data={})".format(self.contract_address, self.from_address, self.to_address, self.token_id, self.additional_data)

        def __eq__(self, other):
            if not other.is_erc721_safe_transfer_from_with_additional_data():
                return False
            if self.contract_address != other.contract_address:
                return False
            if self.from_address != other.from_address:
                return False
            if self.to_address != other.to_address:
                return False
            if self.token_id != other.token_id:
                return False
            if self.additional_data != other.additional_data:
                return False
            return True
    class ERC1155_SAFE_TRANSFER_FROM(object):
        def __init__(self,contract_address, from_address, to_address, token_id, amount, additional_data):
            
            self.contract_address = contract_address
            self.from_address = from_address
            self.to_address = to_address
            self.token_id = token_id
            self.amount = amount
            self.additional_data = additional_data
            

        def __str__(self):
            return "ContractTransfer.ERC1155_SAFE_TRANSFER_FROM(contract_address={}, from_address={}, to_address={}, token_id={}, amount={}, additional_data={})".format(self.contract_address, self.from_address, self.to_address, self.token_id, self.amount, self.additional_data)

        def __eq__(self, other):
            if not other.is_erc1155_safe_transfer_from():
                return False
            if self.contract_address != other.contract_address:
                return False
            if self.from_address != other.from_address:
                return False
            if self.to_address != other.to_address:
                return False
            if self.token_id != other.token_id:
                return False
            if self.amount != other.amount:
                return False
            if self.additional_data != other.additional_data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_erc20_transfer(self):
        return isinstance(self, ContractTransfer.ERC20_TRANSFER)
    def is_erc20_transfer_from(self):
        return isinstance(self, ContractTransfer.ERC20_TRANSFER_FROM)
    def is_erc721_transfer_from(self):
        return isinstance(self, ContractTransfer.ERC721_TRANSFER_FROM)
    def is_erc721_safe_transfer_from(self):
        return isinstance(self, ContractTransfer.ERC721_SAFE_TRANSFER_FROM)
    def is_erc721_safe_transfer_from_with_additional_data(self):
        return isinstance(self, ContractTransfer.ERC721_SAFE_TRANSFER_FROM_WITH_ADDITIONAL_DATA)
    def is_erc1155_safe_transfer_from(self):
        return isinstance(self, ContractTransfer.ERC1155_SAFE_TRANSFER_FROM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ContractTransfer.ERC20_TRANSFER = type("ContractTransfer.ERC20_TRANSFER", (ContractTransfer.ERC20_TRANSFER, ContractTransfer,), {})
ContractTransfer.ERC20_TRANSFER_FROM = type("ContractTransfer.ERC20_TRANSFER_FROM", (ContractTransfer.ERC20_TRANSFER_FROM, ContractTransfer,), {})
ContractTransfer.ERC721_TRANSFER_FROM = type("ContractTransfer.ERC721_TRANSFER_FROM", (ContractTransfer.ERC721_TRANSFER_FROM, ContractTransfer,), {})
ContractTransfer.ERC721_SAFE_TRANSFER_FROM = type("ContractTransfer.ERC721_SAFE_TRANSFER_FROM", (ContractTransfer.ERC721_SAFE_TRANSFER_FROM, ContractTransfer,), {})
ContractTransfer.ERC721_SAFE_TRANSFER_FROM_WITH_ADDITIONAL_DATA = type("ContractTransfer.ERC721_SAFE_TRANSFER_FROM_WITH_ADDITIONAL_DATA", (ContractTransfer.ERC721_SAFE_TRANSFER_FROM_WITH_ADDITIONAL_DATA, ContractTransfer,), {})
ContractTransfer.ERC1155_SAFE_TRANSFER_FROM = type("ContractTransfer.ERC1155_SAFE_TRANSFER_FROM", (ContractTransfer.ERC1155_SAFE_TRANSFER_FROM, ContractTransfer,), {})




class FfiConverterTypeContractTransfer(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ContractTransfer.ERC20_TRANSFER(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return ContractTransfer.ERC20_TRANSFER_FROM(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return ContractTransfer.ERC721_TRANSFER_FROM(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return ContractTransfer.ERC721_SAFE_TRANSFER_FROM(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return ContractTransfer.ERC721_SAFE_TRANSFER_FROM_WITH_ADDITIONAL_DATA(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterSequenceUInt8.read(buf),
            )
        if variant == 6:
            return ContractTransfer.ERC1155_SAFE_TRANSFER_FROM(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterSequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_erc20_transfer():
            buf.writeI32(1)
            FfiConverterString.write(value.contract_address, buf)
            FfiConverterString.write(value.to_address, buf)
            FfiConverterString.write(value.amount, buf)
        if value.is_erc20_transfer_from():
            buf.writeI32(2)
            FfiConverterString.write(value.contract_address, buf)
            FfiConverterString.write(value.from_address, buf)
            FfiConverterString.write(value.to_address, buf)
            FfiConverterString.write(value.amount, buf)
        if value.is_erc721_transfer_from():
            buf.writeI32(3)
            FfiConverterString.write(value.contract_address, buf)
            FfiConverterString.write(value.from_address, buf)
            FfiConverterString.write(value.to_address, buf)
            FfiConverterString.write(value.token_id, buf)
        if value.is_erc721_safe_transfer_from():
            buf.writeI32(4)
            FfiConverterString.write(value.contract_address, buf)
            FfiConverterString.write(value.from_address, buf)
            FfiConverterString.write(value.to_address, buf)
            FfiConverterString.write(value.token_id, buf)
        if value.is_erc721_safe_transfer_from_with_additional_data():
            buf.writeI32(5)
            FfiConverterString.write(value.contract_address, buf)
            FfiConverterString.write(value.from_address, buf)
            FfiConverterString.write(value.to_address, buf)
            FfiConverterString.write(value.token_id, buf)
            FfiConverterSequenceUInt8.write(value.additional_data, buf)
        if value.is_erc1155_safe_transfer_from():
            buf.writeI32(6)
            FfiConverterString.write(value.contract_address, buf)
            FfiConverterString.write(value.from_address, buf)
            FfiConverterString.write(value.to_address, buf)
            FfiConverterString.write(value.token_id, buf)
            FfiConverterString.write(value.amount, buf)
            FfiConverterSequenceUInt8.write(value.additional_data, buf)




class CosmosModeInfo:
    def __init__(self):
        raise RuntimeError("CosmosModeInfo cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SINGLE(object):
        def __init__(self,mode):
            
            self.mode = mode
            

        def __str__(self):
            return "CosmosModeInfo.SINGLE(mode={})".format(self.mode)

        def __eq__(self, other):
            if not other.is_single():
                return False
            if self.mode != other.mode:
                return False
            return True
    class MULTI(object):
        def __init__(self,modes):
            
            self.modes = modes
            

        def __str__(self):
            return "CosmosModeInfo.MULTI(modes={})".format(self.modes)

        def __eq__(self, other):
            if not other.is_multi():
                return False
            if self.modes != other.modes:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_single(self):
        return isinstance(self, CosmosModeInfo.SINGLE)
    def is_multi(self):
        return isinstance(self, CosmosModeInfo.MULTI)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
CosmosModeInfo.SINGLE = type("CosmosModeInfo.SINGLE", (CosmosModeInfo.SINGLE, CosmosModeInfo,), {})
CosmosModeInfo.MULTI = type("CosmosModeInfo.MULTI", (CosmosModeInfo.MULTI, CosmosModeInfo,), {})




class FfiConverterTypeCosmosModeInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return CosmosModeInfo.SINGLE(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return CosmosModeInfo.MULTI(
                FfiConverterSequenceString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_single():
            buf.writeI32(1)
            FfiConverterString.write(value.mode, buf)
        if value.is_multi():
            buf.writeI32(2)
            FfiConverterSequenceString.write(value.modes, buf)




class CosmosRawCryptoOrgMsg:
    def __init__(self):
        raise RuntimeError("CosmosRawCryptoOrgMsg cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NFT_ISSUE_DENOM(object):
        def __init__(self,id, name, schema, sender):
            
            self.id = id
            self.name = name
            self.schema = schema
            self.sender = sender
            

        def __str__(self):
            return "CosmosRawCryptoOrgMsg.NFT_ISSUE_DENOM(id={}, name={}, schema={}, sender={})".format(self.id, self.name, self.schema, self.sender)

        def __eq__(self, other):
            if not other.is_nft_issue_denom():
                return False
            if self.id != other.id:
                return False
            if self.name != other.name:
                return False
            if self.schema != other.schema:
                return False
            if self.sender != other.sender:
                return False
            return True
    class NFT_MINT(object):
        def __init__(self,id, denom_id, name, uri, data, sender, recipient):
            
            self.id = id
            self.denom_id = denom_id
            self.name = name
            self.uri = uri
            self.data = data
            self.sender = sender
            self.recipient = recipient
            

        def __str__(self):
            return "CosmosRawCryptoOrgMsg.NFT_MINT(id={}, denom_id={}, name={}, uri={}, data={}, sender={}, recipient={})".format(self.id, self.denom_id, self.name, self.uri, self.data, self.sender, self.recipient)

        def __eq__(self, other):
            if not other.is_nft_mint():
                return False
            if self.id != other.id:
                return False
            if self.denom_id != other.denom_id:
                return False
            if self.name != other.name:
                return False
            if self.uri != other.uri:
                return False
            if self.data != other.data:
                return False
            if self.sender != other.sender:
                return False
            if self.recipient != other.recipient:
                return False
            return True
    class NFT_EDIT(object):
        def __init__(self,id, denom_id, name, uri, data, sender):
            
            self.id = id
            self.denom_id = denom_id
            self.name = name
            self.uri = uri
            self.data = data
            self.sender = sender
            

        def __str__(self):
            return "CosmosRawCryptoOrgMsg.NFT_EDIT(id={}, denom_id={}, name={}, uri={}, data={}, sender={})".format(self.id, self.denom_id, self.name, self.uri, self.data, self.sender)

        def __eq__(self, other):
            if not other.is_nft_edit():
                return False
            if self.id != other.id:
                return False
            if self.denom_id != other.denom_id:
                return False
            if self.name != other.name:
                return False
            if self.uri != other.uri:
                return False
            if self.data != other.data:
                return False
            if self.sender != other.sender:
                return False
            return True
    class NFT_TRANSFER(object):
        def __init__(self,id, denom_id, sender, recipient):
            
            self.id = id
            self.denom_id = denom_id
            self.sender = sender
            self.recipient = recipient
            

        def __str__(self):
            return "CosmosRawCryptoOrgMsg.NFT_TRANSFER(id={}, denom_id={}, sender={}, recipient={})".format(self.id, self.denom_id, self.sender, self.recipient)

        def __eq__(self, other):
            if not other.is_nft_transfer():
                return False
            if self.id != other.id:
                return False
            if self.denom_id != other.denom_id:
                return False
            if self.sender != other.sender:
                return False
            if self.recipient != other.recipient:
                return False
            return True
    class NFT_BURN(object):
        def __init__(self,id, denom_id, sender):
            
            self.id = id
            self.denom_id = denom_id
            self.sender = sender
            

        def __str__(self):
            return "CosmosRawCryptoOrgMsg.NFT_BURN(id={}, denom_id={}, sender={})".format(self.id, self.denom_id, self.sender)

        def __eq__(self, other):
            if not other.is_nft_burn():
                return False
            if self.id != other.id:
                return False
            if self.denom_id != other.denom_id:
                return False
            if self.sender != other.sender:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_nft_issue_denom(self):
        return isinstance(self, CosmosRawCryptoOrgMsg.NFT_ISSUE_DENOM)
    def is_nft_mint(self):
        return isinstance(self, CosmosRawCryptoOrgMsg.NFT_MINT)
    def is_nft_edit(self):
        return isinstance(self, CosmosRawCryptoOrgMsg.NFT_EDIT)
    def is_nft_transfer(self):
        return isinstance(self, CosmosRawCryptoOrgMsg.NFT_TRANSFER)
    def is_nft_burn(self):
        return isinstance(self, CosmosRawCryptoOrgMsg.NFT_BURN)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
CosmosRawCryptoOrgMsg.NFT_ISSUE_DENOM = type("CosmosRawCryptoOrgMsg.NFT_ISSUE_DENOM", (CosmosRawCryptoOrgMsg.NFT_ISSUE_DENOM, CosmosRawCryptoOrgMsg,), {})
CosmosRawCryptoOrgMsg.NFT_MINT = type("CosmosRawCryptoOrgMsg.NFT_MINT", (CosmosRawCryptoOrgMsg.NFT_MINT, CosmosRawCryptoOrgMsg,), {})
CosmosRawCryptoOrgMsg.NFT_EDIT = type("CosmosRawCryptoOrgMsg.NFT_EDIT", (CosmosRawCryptoOrgMsg.NFT_EDIT, CosmosRawCryptoOrgMsg,), {})
CosmosRawCryptoOrgMsg.NFT_TRANSFER = type("CosmosRawCryptoOrgMsg.NFT_TRANSFER", (CosmosRawCryptoOrgMsg.NFT_TRANSFER, CosmosRawCryptoOrgMsg,), {})
CosmosRawCryptoOrgMsg.NFT_BURN = type("CosmosRawCryptoOrgMsg.NFT_BURN", (CosmosRawCryptoOrgMsg.NFT_BURN, CosmosRawCryptoOrgMsg,), {})




class FfiConverterTypeCosmosRawCryptoOrgMsg(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return CosmosRawCryptoOrgMsg.NFT_ISSUE_DENOM(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return CosmosRawCryptoOrgMsg.NFT_MINT(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return CosmosRawCryptoOrgMsg.NFT_EDIT(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return CosmosRawCryptoOrgMsg.NFT_TRANSFER(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return CosmosRawCryptoOrgMsg.NFT_BURN(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_nft_issue_denom():
            buf.writeI32(1)
            FfiConverterString.write(value.id, buf)
            FfiConverterString.write(value.name, buf)
            FfiConverterString.write(value.schema, buf)
            FfiConverterString.write(value.sender, buf)
        if value.is_nft_mint():
            buf.writeI32(2)
            FfiConverterString.write(value.id, buf)
            FfiConverterString.write(value.denom_id, buf)
            FfiConverterString.write(value.name, buf)
            FfiConverterString.write(value.uri, buf)
            FfiConverterString.write(value.data, buf)
            FfiConverterString.write(value.sender, buf)
            FfiConverterString.write(value.recipient, buf)
        if value.is_nft_edit():
            buf.writeI32(3)
            FfiConverterString.write(value.id, buf)
            FfiConverterString.write(value.denom_id, buf)
            FfiConverterString.write(value.name, buf)
            FfiConverterString.write(value.uri, buf)
            FfiConverterString.write(value.data, buf)
            FfiConverterString.write(value.sender, buf)
        if value.is_nft_transfer():
            buf.writeI32(4)
            FfiConverterString.write(value.id, buf)
            FfiConverterString.write(value.denom_id, buf)
            FfiConverterString.write(value.sender, buf)
            FfiConverterString.write(value.recipient, buf)
        if value.is_nft_burn():
            buf.writeI32(5)
            FfiConverterString.write(value.id, buf)
            FfiConverterString.write(value.denom_id, buf)
            FfiConverterString.write(value.sender, buf)




class CosmosRawMsg:
    def __init__(self):
        raise RuntimeError("CosmosRawMsg cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NORMAL(object):
        def __init__(self,msg):
            
            self.msg = msg
            

        def __str__(self):
            return "CosmosRawMsg.NORMAL(msg={})".format(self.msg)

        def __eq__(self, other):
            if not other.is_normal():
                return False
            if self.msg != other.msg:
                return False
            return True
    class CRYPTO_ORG(object):
        def __init__(self,msg):
            
            self.msg = msg
            

        def __str__(self):
            return "CosmosRawMsg.CRYPTO_ORG(msg={})".format(self.msg)

        def __eq__(self, other):
            if not other.is_crypto_org():
                return False
            if self.msg != other.msg:
                return False
            return True
    class ANY(object):
        def __init__(self,type_url, value):
            
            self.type_url = type_url
            self.value = value
            

        def __str__(self):
            return "CosmosRawMsg.ANY(type_url={}, value={})".format(self.type_url, self.value)

        def __eq__(self, other):
            if not other.is_any():
                return False
            if self.type_url != other.type_url:
                return False
            if self.value != other.value:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_normal(self):
        return isinstance(self, CosmosRawMsg.NORMAL)
    def is_crypto_org(self):
        return isinstance(self, CosmosRawMsg.CRYPTO_ORG)
    def is_any(self):
        return isinstance(self, CosmosRawMsg.ANY)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
CosmosRawMsg.NORMAL = type("CosmosRawMsg.NORMAL", (CosmosRawMsg.NORMAL, CosmosRawMsg,), {})
CosmosRawMsg.CRYPTO_ORG = type("CosmosRawMsg.CRYPTO_ORG", (CosmosRawMsg.CRYPTO_ORG, CosmosRawMsg,), {})
CosmosRawMsg.ANY = type("CosmosRawMsg.ANY", (CosmosRawMsg.ANY, CosmosRawMsg,), {})




class FfiConverterTypeCosmosRawMsg(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return CosmosRawMsg.NORMAL(
                FfiConverterTypeCosmosRawNormalMsg.read(buf),
            )
        if variant == 2:
            return CosmosRawMsg.CRYPTO_ORG(
                FfiConverterTypeCosmosRawCryptoOrgMsg.read(buf),
            )
        if variant == 3:
            return CosmosRawMsg.ANY(
                FfiConverterString.read(buf),
                FfiConverterSequenceUInt8.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_normal():
            buf.writeI32(1)
            FfiConverterTypeCosmosRawNormalMsg.write(value.msg, buf)
        if value.is_crypto_org():
            buf.writeI32(2)
            FfiConverterTypeCosmosRawCryptoOrgMsg.write(value.msg, buf)
        if value.is_any():
            buf.writeI32(3)
            FfiConverterString.write(value.type_url, buf)
            FfiConverterSequenceUInt8.write(value.value, buf)




class CosmosRawNormalMsg:
    def __init__(self):
        raise RuntimeError("CosmosRawNormalMsg cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BANK_SEND(object):
        def __init__(self,from_address, to_address, amount):
            
            self.from_address = from_address
            self.to_address = to_address
            self.amount = amount
            

        def __str__(self):
            return "CosmosRawNormalMsg.BANK_SEND(from_address={}, to_address={}, amount={})".format(self.from_address, self.to_address, self.amount)

        def __eq__(self, other):
            if not other.is_bank_send():
                return False
            if self.from_address != other.from_address:
                return False
            if self.to_address != other.to_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class STAKING_BEGIN_REDELEGATE(object):
        def __init__(self,delegator_address, validator_src_address, validator_dst_address, amount):
            
            self.delegator_address = delegator_address
            self.validator_src_address = validator_src_address
            self.validator_dst_address = validator_dst_address
            self.amount = amount
            

        def __str__(self):
            return "CosmosRawNormalMsg.STAKING_BEGIN_REDELEGATE(delegator_address={}, validator_src_address={}, validator_dst_address={}, amount={})".format(self.delegator_address, self.validator_src_address, self.validator_dst_address, self.amount)

        def __eq__(self, other):
            if not other.is_staking_begin_redelegate():
                return False
            if self.delegator_address != other.delegator_address:
                return False
            if self.validator_src_address != other.validator_src_address:
                return False
            if self.validator_dst_address != other.validator_dst_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class STAKING_DELEGATE(object):
        def __init__(self,delegator_address, validator_address, amount):
            
            self.delegator_address = delegator_address
            self.validator_address = validator_address
            self.amount = amount
            

        def __str__(self):
            return "CosmosRawNormalMsg.STAKING_DELEGATE(delegator_address={}, validator_address={}, amount={})".format(self.delegator_address, self.validator_address, self.amount)

        def __eq__(self, other):
            if not other.is_staking_delegate():
                return False
            if self.delegator_address != other.delegator_address:
                return False
            if self.validator_address != other.validator_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class STAKING_UNDELEGATE(object):
        def __init__(self,delegator_address, validator_address, amount):
            
            self.delegator_address = delegator_address
            self.validator_address = validator_address
            self.amount = amount
            

        def __str__(self):
            return "CosmosRawNormalMsg.STAKING_UNDELEGATE(delegator_address={}, validator_address={}, amount={})".format(self.delegator_address, self.validator_address, self.amount)

        def __eq__(self, other):
            if not other.is_staking_undelegate():
                return False
            if self.delegator_address != other.delegator_address:
                return False
            if self.validator_address != other.validator_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class DISTRIBUTION_SET_WITHDRAW_ADDRESS(object):
        def __init__(self,delegator_address, withdraw_address):
            
            self.delegator_address = delegator_address
            self.withdraw_address = withdraw_address
            

        def __str__(self):
            return "CosmosRawNormalMsg.DISTRIBUTION_SET_WITHDRAW_ADDRESS(delegator_address={}, withdraw_address={})".format(self.delegator_address, self.withdraw_address)

        def __eq__(self, other):
            if not other.is_distribution_set_withdraw_address():
                return False
            if self.delegator_address != other.delegator_address:
                return False
            if self.withdraw_address != other.withdraw_address:
                return False
            return True
    class DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD(object):
        def __init__(self,delegator_address, validator_address):
            
            self.delegator_address = delegator_address
            self.validator_address = validator_address
            

        def __str__(self):
            return "CosmosRawNormalMsg.DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD(delegator_address={}, validator_address={})".format(self.delegator_address, self.validator_address)

        def __eq__(self, other):
            if not other.is_distribution_withdraw_delegator_reward():
                return False
            if self.delegator_address != other.delegator_address:
                return False
            if self.validator_address != other.validator_address:
                return False
            return True
    class IBC_TRANSFER(object):
        def __init__(self,sender, receiver, source_port, source_channel, token, timeout_height, timeout_timestamp):
            
            self.sender = sender
            self.receiver = receiver
            self.source_port = source_port
            self.source_channel = source_channel
            self.token = token
            self.timeout_height = timeout_height
            self.timeout_timestamp = timeout_timestamp
            

        def __str__(self):
            return "CosmosRawNormalMsg.IBC_TRANSFER(sender={}, receiver={}, source_port={}, source_channel={}, token={}, timeout_height={}, timeout_timestamp={})".format(self.sender, self.receiver, self.source_port, self.source_channel, self.token, self.timeout_height, self.timeout_timestamp)

        def __eq__(self, other):
            if not other.is_ibc_transfer():
                return False
            if self.sender != other.sender:
                return False
            if self.receiver != other.receiver:
                return False
            if self.source_port != other.source_port:
                return False
            if self.source_channel != other.source_channel:
                return False
            if self.token != other.token:
                return False
            if self.timeout_height != other.timeout_height:
                return False
            if self.timeout_timestamp != other.timeout_timestamp:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bank_send(self):
        return isinstance(self, CosmosRawNormalMsg.BANK_SEND)
    def is_staking_begin_redelegate(self):
        return isinstance(self, CosmosRawNormalMsg.STAKING_BEGIN_REDELEGATE)
    def is_staking_delegate(self):
        return isinstance(self, CosmosRawNormalMsg.STAKING_DELEGATE)
    def is_staking_undelegate(self):
        return isinstance(self, CosmosRawNormalMsg.STAKING_UNDELEGATE)
    def is_distribution_set_withdraw_address(self):
        return isinstance(self, CosmosRawNormalMsg.DISTRIBUTION_SET_WITHDRAW_ADDRESS)
    def is_distribution_withdraw_delegator_reward(self):
        return isinstance(self, CosmosRawNormalMsg.DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD)
    def is_ibc_transfer(self):
        return isinstance(self, CosmosRawNormalMsg.IBC_TRANSFER)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
CosmosRawNormalMsg.BANK_SEND = type("CosmosRawNormalMsg.BANK_SEND", (CosmosRawNormalMsg.BANK_SEND, CosmosRawNormalMsg,), {})
CosmosRawNormalMsg.STAKING_BEGIN_REDELEGATE = type("CosmosRawNormalMsg.STAKING_BEGIN_REDELEGATE", (CosmosRawNormalMsg.STAKING_BEGIN_REDELEGATE, CosmosRawNormalMsg,), {})
CosmosRawNormalMsg.STAKING_DELEGATE = type("CosmosRawNormalMsg.STAKING_DELEGATE", (CosmosRawNormalMsg.STAKING_DELEGATE, CosmosRawNormalMsg,), {})
CosmosRawNormalMsg.STAKING_UNDELEGATE = type("CosmosRawNormalMsg.STAKING_UNDELEGATE", (CosmosRawNormalMsg.STAKING_UNDELEGATE, CosmosRawNormalMsg,), {})
CosmosRawNormalMsg.DISTRIBUTION_SET_WITHDRAW_ADDRESS = type("CosmosRawNormalMsg.DISTRIBUTION_SET_WITHDRAW_ADDRESS", (CosmosRawNormalMsg.DISTRIBUTION_SET_WITHDRAW_ADDRESS, CosmosRawNormalMsg,), {})
CosmosRawNormalMsg.DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD = type("CosmosRawNormalMsg.DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD", (CosmosRawNormalMsg.DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD, CosmosRawNormalMsg,), {})
CosmosRawNormalMsg.IBC_TRANSFER = type("CosmosRawNormalMsg.IBC_TRANSFER", (CosmosRawNormalMsg.IBC_TRANSFER, CosmosRawNormalMsg,), {})




class FfiConverterTypeCosmosRawNormalMsg(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return CosmosRawNormalMsg.BANK_SEND(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterSequenceTypeSingleCoin.read(buf),
            )
        if variant == 2:
            return CosmosRawNormalMsg.STAKING_BEGIN_REDELEGATE(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeSingleCoin.read(buf),
            )
        if variant == 3:
            return CosmosRawNormalMsg.STAKING_DELEGATE(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeSingleCoin.read(buf),
            )
        if variant == 4:
            return CosmosRawNormalMsg.STAKING_UNDELEGATE(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeSingleCoin.read(buf),
            )
        if variant == 5:
            return CosmosRawNormalMsg.DISTRIBUTION_SET_WITHDRAW_ADDRESS(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return CosmosRawNormalMsg.DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 7:
            return CosmosRawNormalMsg.IBC_TRANSFER(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeSingleCoin.read(buf),
                FfiConverterTypeHeight.read(buf),
                FfiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_bank_send():
            buf.writeI32(1)
            FfiConverterString.write(value.from_address, buf)
            FfiConverterString.write(value.to_address, buf)
            FfiConverterSequenceTypeSingleCoin.write(value.amount, buf)
        if value.is_staking_begin_redelegate():
            buf.writeI32(2)
            FfiConverterString.write(value.delegator_address, buf)
            FfiConverterString.write(value.validator_src_address, buf)
            FfiConverterString.write(value.validator_dst_address, buf)
            FfiConverterTypeSingleCoin.write(value.amount, buf)
        if value.is_staking_delegate():
            buf.writeI32(3)
            FfiConverterString.write(value.delegator_address, buf)
            FfiConverterString.write(value.validator_address, buf)
            FfiConverterTypeSingleCoin.write(value.amount, buf)
        if value.is_staking_undelegate():
            buf.writeI32(4)
            FfiConverterString.write(value.delegator_address, buf)
            FfiConverterString.write(value.validator_address, buf)
            FfiConverterTypeSingleCoin.write(value.amount, buf)
        if value.is_distribution_set_withdraw_address():
            buf.writeI32(5)
            FfiConverterString.write(value.delegator_address, buf)
            FfiConverterString.write(value.withdraw_address, buf)
        if value.is_distribution_withdraw_delegator_reward():
            buf.writeI32(6)
            FfiConverterString.write(value.delegator_address, buf)
            FfiConverterString.write(value.validator_address, buf)
        if value.is_ibc_transfer():
            buf.writeI32(7)
            FfiConverterString.write(value.sender, buf)
            FfiConverterString.write(value.receiver, buf)
            FfiConverterString.write(value.source_port, buf)
            FfiConverterString.write(value.source_channel, buf)
            FfiConverterTypeSingleCoin.write(value.token, buf)
            FfiConverterTypeHeight.write(value.timeout_height, buf)
            FfiConverterUInt64.write(value.timeout_timestamp, buf)




class CosmosSdkMsg:
    def __init__(self):
        raise RuntimeError("CosmosSdkMsg cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BANK_SEND(object):
        def __init__(self,recipient_address, amount):
            
            self.recipient_address = recipient_address
            self.amount = amount
            

        def __str__(self):
            return "CosmosSdkMsg.BANK_SEND(recipient_address={}, amount={})".format(self.recipient_address, self.amount)

        def __eq__(self, other):
            if not other.is_bank_send():
                return False
            if self.recipient_address != other.recipient_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class NFT_ISSUE_DENOM(object):
        def __init__(self,id, name, schema):
            
            self.id = id
            self.name = name
            self.schema = schema
            

        def __str__(self):
            return "CosmosSdkMsg.NFT_ISSUE_DENOM(id={}, name={}, schema={})".format(self.id, self.name, self.schema)

        def __eq__(self, other):
            if not other.is_nft_issue_denom():
                return False
            if self.id != other.id:
                return False
            if self.name != other.name:
                return False
            if self.schema != other.schema:
                return False
            return True
    class NFT_MINT(object):
        def __init__(self,id, denom_id, name, uri, data, recipient):
            
            self.id = id
            self.denom_id = denom_id
            self.name = name
            self.uri = uri
            self.data = data
            self.recipient = recipient
            

        def __str__(self):
            return "CosmosSdkMsg.NFT_MINT(id={}, denom_id={}, name={}, uri={}, data={}, recipient={})".format(self.id, self.denom_id, self.name, self.uri, self.data, self.recipient)

        def __eq__(self, other):
            if not other.is_nft_mint():
                return False
            if self.id != other.id:
                return False
            if self.denom_id != other.denom_id:
                return False
            if self.name != other.name:
                return False
            if self.uri != other.uri:
                return False
            if self.data != other.data:
                return False
            if self.recipient != other.recipient:
                return False
            return True
    class NFT_EDIT(object):
        def __init__(self,id, denom_id, name, uri, data):
            
            self.id = id
            self.denom_id = denom_id
            self.name = name
            self.uri = uri
            self.data = data
            

        def __str__(self):
            return "CosmosSdkMsg.NFT_EDIT(id={}, denom_id={}, name={}, uri={}, data={})".format(self.id, self.denom_id, self.name, self.uri, self.data)

        def __eq__(self, other):
            if not other.is_nft_edit():
                return False
            if self.id != other.id:
                return False
            if self.denom_id != other.denom_id:
                return False
            if self.name != other.name:
                return False
            if self.uri != other.uri:
                return False
            if self.data != other.data:
                return False
            return True
    class NFT_TRANSFER(object):
        def __init__(self,id, denom_id, recipient):
            
            self.id = id
            self.denom_id = denom_id
            self.recipient = recipient
            

        def __str__(self):
            return "CosmosSdkMsg.NFT_TRANSFER(id={}, denom_id={}, recipient={})".format(self.id, self.denom_id, self.recipient)

        def __eq__(self, other):
            if not other.is_nft_transfer():
                return False
            if self.id != other.id:
                return False
            if self.denom_id != other.denom_id:
                return False
            if self.recipient != other.recipient:
                return False
            return True
    class NFT_BURN(object):
        def __init__(self,id, denom_id):
            
            self.id = id
            self.denom_id = denom_id
            

        def __str__(self):
            return "CosmosSdkMsg.NFT_BURN(id={}, denom_id={})".format(self.id, self.denom_id)

        def __eq__(self, other):
            if not other.is_nft_burn():
                return False
            if self.id != other.id:
                return False
            if self.denom_id != other.denom_id:
                return False
            return True
    class STAKING_DELEGATE(object):
        def __init__(self,validator_address, amount):
            
            self.validator_address = validator_address
            self.amount = amount
            

        def __str__(self):
            return "CosmosSdkMsg.STAKING_DELEGATE(validator_address={}, amount={})".format(self.validator_address, self.amount)

        def __eq__(self, other):
            if not other.is_staking_delegate():
                return False
            if self.validator_address != other.validator_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class STAKING_UNDELEGATE(object):
        def __init__(self,validator_address, amount):
            
            self.validator_address = validator_address
            self.amount = amount
            

        def __str__(self):
            return "CosmosSdkMsg.STAKING_UNDELEGATE(validator_address={}, amount={})".format(self.validator_address, self.amount)

        def __eq__(self, other):
            if not other.is_staking_undelegate():
                return False
            if self.validator_address != other.validator_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class STAKING_BEGIN_REDELEGATE(object):
        def __init__(self,validator_src_address, validator_dst_address, amount):
            
            self.validator_src_address = validator_src_address
            self.validator_dst_address = validator_dst_address
            self.amount = amount
            

        def __str__(self):
            return "CosmosSdkMsg.STAKING_BEGIN_REDELEGATE(validator_src_address={}, validator_dst_address={}, amount={})".format(self.validator_src_address, self.validator_dst_address, self.amount)

        def __eq__(self, other):
            if not other.is_staking_begin_redelegate():
                return False
            if self.validator_src_address != other.validator_src_address:
                return False
            if self.validator_dst_address != other.validator_dst_address:
                return False
            if self.amount != other.amount:
                return False
            return True
    class DISTRIBUTION_SET_WITHDRAW_ADDRESS(object):
        def __init__(self,withdraw_address):
            
            self.withdraw_address = withdraw_address
            

        def __str__(self):
            return "CosmosSdkMsg.DISTRIBUTION_SET_WITHDRAW_ADDRESS(withdraw_address={})".format(self.withdraw_address)

        def __eq__(self, other):
            if not other.is_distribution_set_withdraw_address():
                return False
            if self.withdraw_address != other.withdraw_address:
                return False
            return True
    class DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD(object):
        def __init__(self,validator_address):
            
            self.validator_address = validator_address
            

        def __str__(self):
            return "CosmosSdkMsg.DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD(validator_address={})".format(self.validator_address)

        def __eq__(self, other):
            if not other.is_distribution_withdraw_delegator_reward():
                return False
            if self.validator_address != other.validator_address:
                return False
            return True
    class IBC_TRANSFER(object):
        def __init__(self,receiver, source_port, source_channel, token, timeout_height, timeout_timestamp):
            
            self.receiver = receiver
            self.source_port = source_port
            self.source_channel = source_channel
            self.token = token
            self.timeout_height = timeout_height
            self.timeout_timestamp = timeout_timestamp
            

        def __str__(self):
            return "CosmosSdkMsg.IBC_TRANSFER(receiver={}, source_port={}, source_channel={}, token={}, timeout_height={}, timeout_timestamp={})".format(self.receiver, self.source_port, self.source_channel, self.token, self.timeout_height, self.timeout_timestamp)

        def __eq__(self, other):
            if not other.is_ibc_transfer():
                return False
            if self.receiver != other.receiver:
                return False
            if self.source_port != other.source_port:
                return False
            if self.source_channel != other.source_channel:
                return False
            if self.token != other.token:
                return False
            if self.timeout_height != other.timeout_height:
                return False
            if self.timeout_timestamp != other.timeout_timestamp:
                return False
            return True
    class EXECUTE_CONTRACT(object):
        def __init__(self,contract, execute_msg, coins):
            
            self.contract = contract
            self.execute_msg = execute_msg
            self.coins = coins
            

        def __str__(self):
            return "CosmosSdkMsg.EXECUTE_CONTRACT(contract={}, execute_msg={}, coins={})".format(self.contract, self.execute_msg, self.coins)

        def __eq__(self, other):
            if not other.is_execute_contract():
                return False
            if self.contract != other.contract:
                return False
            if self.execute_msg != other.execute_msg:
                return False
            if self.coins != other.coins:
                return False
            return True
    class RAW(object):
        def __init__(self,raw_msg):
            
            self.raw_msg = raw_msg
            

        def __str__(self):
            return "CosmosSdkMsg.RAW(raw_msg={})".format(self.raw_msg)

        def __eq__(self, other):
            if not other.is_raw():
                return False
            if self.raw_msg != other.raw_msg:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_bank_send(self):
        return isinstance(self, CosmosSdkMsg.BANK_SEND)
    def is_nft_issue_denom(self):
        return isinstance(self, CosmosSdkMsg.NFT_ISSUE_DENOM)
    def is_nft_mint(self):
        return isinstance(self, CosmosSdkMsg.NFT_MINT)
    def is_nft_edit(self):
        return isinstance(self, CosmosSdkMsg.NFT_EDIT)
    def is_nft_transfer(self):
        return isinstance(self, CosmosSdkMsg.NFT_TRANSFER)
    def is_nft_burn(self):
        return isinstance(self, CosmosSdkMsg.NFT_BURN)
    def is_staking_delegate(self):
        return isinstance(self, CosmosSdkMsg.STAKING_DELEGATE)
    def is_staking_undelegate(self):
        return isinstance(self, CosmosSdkMsg.STAKING_UNDELEGATE)
    def is_staking_begin_redelegate(self):
        return isinstance(self, CosmosSdkMsg.STAKING_BEGIN_REDELEGATE)
    def is_distribution_set_withdraw_address(self):
        return isinstance(self, CosmosSdkMsg.DISTRIBUTION_SET_WITHDRAW_ADDRESS)
    def is_distribution_withdraw_delegator_reward(self):
        return isinstance(self, CosmosSdkMsg.DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD)
    def is_ibc_transfer(self):
        return isinstance(self, CosmosSdkMsg.IBC_TRANSFER)
    def is_execute_contract(self):
        return isinstance(self, CosmosSdkMsg.EXECUTE_CONTRACT)
    def is_raw(self):
        return isinstance(self, CosmosSdkMsg.RAW)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
CosmosSdkMsg.BANK_SEND = type("CosmosSdkMsg.BANK_SEND", (CosmosSdkMsg.BANK_SEND, CosmosSdkMsg,), {})
CosmosSdkMsg.NFT_ISSUE_DENOM = type("CosmosSdkMsg.NFT_ISSUE_DENOM", (CosmosSdkMsg.NFT_ISSUE_DENOM, CosmosSdkMsg,), {})
CosmosSdkMsg.NFT_MINT = type("CosmosSdkMsg.NFT_MINT", (CosmosSdkMsg.NFT_MINT, CosmosSdkMsg,), {})
CosmosSdkMsg.NFT_EDIT = type("CosmosSdkMsg.NFT_EDIT", (CosmosSdkMsg.NFT_EDIT, CosmosSdkMsg,), {})
CosmosSdkMsg.NFT_TRANSFER = type("CosmosSdkMsg.NFT_TRANSFER", (CosmosSdkMsg.NFT_TRANSFER, CosmosSdkMsg,), {})
CosmosSdkMsg.NFT_BURN = type("CosmosSdkMsg.NFT_BURN", (CosmosSdkMsg.NFT_BURN, CosmosSdkMsg,), {})
CosmosSdkMsg.STAKING_DELEGATE = type("CosmosSdkMsg.STAKING_DELEGATE", (CosmosSdkMsg.STAKING_DELEGATE, CosmosSdkMsg,), {})
CosmosSdkMsg.STAKING_UNDELEGATE = type("CosmosSdkMsg.STAKING_UNDELEGATE", (CosmosSdkMsg.STAKING_UNDELEGATE, CosmosSdkMsg,), {})
CosmosSdkMsg.STAKING_BEGIN_REDELEGATE = type("CosmosSdkMsg.STAKING_BEGIN_REDELEGATE", (CosmosSdkMsg.STAKING_BEGIN_REDELEGATE, CosmosSdkMsg,), {})
CosmosSdkMsg.DISTRIBUTION_SET_WITHDRAW_ADDRESS = type("CosmosSdkMsg.DISTRIBUTION_SET_WITHDRAW_ADDRESS", (CosmosSdkMsg.DISTRIBUTION_SET_WITHDRAW_ADDRESS, CosmosSdkMsg,), {})
CosmosSdkMsg.DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD = type("CosmosSdkMsg.DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD", (CosmosSdkMsg.DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD, CosmosSdkMsg,), {})
CosmosSdkMsg.IBC_TRANSFER = type("CosmosSdkMsg.IBC_TRANSFER", (CosmosSdkMsg.IBC_TRANSFER, CosmosSdkMsg,), {})
CosmosSdkMsg.EXECUTE_CONTRACT = type("CosmosSdkMsg.EXECUTE_CONTRACT", (CosmosSdkMsg.EXECUTE_CONTRACT, CosmosSdkMsg,), {})
CosmosSdkMsg.RAW = type("CosmosSdkMsg.RAW", (CosmosSdkMsg.RAW, CosmosSdkMsg,), {})




class FfiConverterTypeCosmosSdkMsg(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return CosmosSdkMsg.BANK_SEND(
                FfiConverterString.read(buf),
                FfiConverterTypeSingleCoin.read(buf),
            )
        if variant == 2:
            return CosmosSdkMsg.NFT_ISSUE_DENOM(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return CosmosSdkMsg.NFT_MINT(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return CosmosSdkMsg.NFT_EDIT(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return CosmosSdkMsg.NFT_TRANSFER(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return CosmosSdkMsg.NFT_BURN(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        if variant == 7:
            return CosmosSdkMsg.STAKING_DELEGATE(
                FfiConverterString.read(buf),
                FfiConverterTypeSingleCoin.read(buf),
            )
        if variant == 8:
            return CosmosSdkMsg.STAKING_UNDELEGATE(
                FfiConverterString.read(buf),
                FfiConverterTypeSingleCoin.read(buf),
            )
        if variant == 9:
            return CosmosSdkMsg.STAKING_BEGIN_REDELEGATE(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeSingleCoin.read(buf),
            )
        if variant == 10:
            return CosmosSdkMsg.DISTRIBUTION_SET_WITHDRAW_ADDRESS(
                FfiConverterString.read(buf),
            )
        if variant == 11:
            return CosmosSdkMsg.DISTRIBUTION_WITHDRAW_DELEGATOR_REWARD(
                FfiConverterString.read(buf),
            )
        if variant == 12:
            return CosmosSdkMsg.IBC_TRANSFER(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
                FfiConverterTypeSingleCoin.read(buf),
                FfiConverterTypeHeight.read(buf),
                FfiConverterUInt64.read(buf),
            )
        if variant == 13:
            return CosmosSdkMsg.EXECUTE_CONTRACT(
                FfiConverterString.read(buf),
                FfiConverterSequenceUInt8.read(buf),
                FfiConverterTypeSingleCoin.read(buf),
            )
        if variant == 14:
            return CosmosSdkMsg.RAW(
                FfiConverterTypeCosmosRawMsg.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_bank_send():
            buf.writeI32(1)
            FfiConverterString.write(value.recipient_address, buf)
            FfiConverterTypeSingleCoin.write(value.amount, buf)
        if value.is_nft_issue_denom():
            buf.writeI32(2)
            FfiConverterString.write(value.id, buf)
            FfiConverterString.write(value.name, buf)
            FfiConverterString.write(value.schema, buf)
        if value.is_nft_mint():
            buf.writeI32(3)
            FfiConverterString.write(value.id, buf)
            FfiConverterString.write(value.denom_id, buf)
            FfiConverterString.write(value.name, buf)
            FfiConverterString.write(value.uri, buf)
            FfiConverterString.write(value.data, buf)
            FfiConverterString.write(value.recipient, buf)
        if value.is_nft_edit():
            buf.writeI32(4)
            FfiConverterString.write(value.id, buf)
            FfiConverterString.write(value.denom_id, buf)
            FfiConverterString.write(value.name, buf)
            FfiConverterString.write(value.uri, buf)
            FfiConverterString.write(value.data, buf)
        if value.is_nft_transfer():
            buf.writeI32(5)
            FfiConverterString.write(value.id, buf)
            FfiConverterString.write(value.denom_id, buf)
            FfiConverterString.write(value.recipient, buf)
        if value.is_nft_burn():
            buf.writeI32(6)
            FfiConverterString.write(value.id, buf)
            FfiConverterString.write(value.denom_id, buf)
        if value.is_staking_delegate():
            buf.writeI32(7)
            FfiConverterString.write(value.validator_address, buf)
            FfiConverterTypeSingleCoin.write(value.amount, buf)
        if value.is_staking_undelegate():
            buf.writeI32(8)
            FfiConverterString.write(value.validator_address, buf)
            FfiConverterTypeSingleCoin.write(value.amount, buf)
        if value.is_staking_begin_redelegate():
            buf.writeI32(9)
            FfiConverterString.write(value.validator_src_address, buf)
            FfiConverterString.write(value.validator_dst_address, buf)
            FfiConverterTypeSingleCoin.write(value.amount, buf)
        if value.is_distribution_set_withdraw_address():
            buf.writeI32(10)
            FfiConverterString.write(value.withdraw_address, buf)
        if value.is_distribution_withdraw_delegator_reward():
            buf.writeI32(11)
            FfiConverterString.write(value.validator_address, buf)
        if value.is_ibc_transfer():
            buf.writeI32(12)
            FfiConverterString.write(value.receiver, buf)
            FfiConverterString.write(value.source_port, buf)
            FfiConverterString.write(value.source_channel, buf)
            FfiConverterTypeSingleCoin.write(value.token, buf)
            FfiConverterTypeHeight.write(value.timeout_height, buf)
            FfiConverterUInt64.write(value.timeout_timestamp, buf)
        if value.is_execute_contract():
            buf.writeI32(13)
            FfiConverterString.write(value.contract, buf)
            FfiConverterSequenceUInt8.write(value.execute_msg, buf)
            FfiConverterTypeSingleCoin.write(value.coins, buf)
        if value.is_raw():
            buf.writeI32(14)
            FfiConverterTypeCosmosRawMsg.write(value.raw_msg, buf)




class CosmosSignerPublicKey:
    def __init__(self):
        raise RuntimeError("CosmosSignerPublicKey cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SINGLE(object):
        def __init__(self,key):
            
            self.key = key
            

        def __str__(self):
            return "CosmosSignerPublicKey.SINGLE(key={})".format(self.key)

        def __eq__(self, other):
            if not other.is_single():
                return False
            if self.key != other.key:
                return False
            return True
    class LEGACY_AMINO_MULTISIG(object):
        def __init__(self,key):
            
            self.key = key
            

        def __str__(self):
            return "CosmosSignerPublicKey.LEGACY_AMINO_MULTISIG(key={})".format(self.key)

        def __eq__(self, other):
            if not other.is_legacy_amino_multisig():
                return False
            if self.key != other.key:
                return False
            return True
    class ANY(object):
        def __init__(self,key):
            
            self.key = key
            

        def __str__(self):
            return "CosmosSignerPublicKey.ANY(key={})".format(self.key)

        def __eq__(self, other):
            if not other.is_any():
                return False
            if self.key != other.key:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_single(self):
        return isinstance(self, CosmosSignerPublicKey.SINGLE)
    def is_legacy_amino_multisig(self):
        return isinstance(self, CosmosSignerPublicKey.LEGACY_AMINO_MULTISIG)
    def is_any(self):
        return isinstance(self, CosmosSignerPublicKey.ANY)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
CosmosSignerPublicKey.SINGLE = type("CosmosSignerPublicKey.SINGLE", (CosmosSignerPublicKey.SINGLE, CosmosSignerPublicKey,), {})
CosmosSignerPublicKey.LEGACY_AMINO_MULTISIG = type("CosmosSignerPublicKey.LEGACY_AMINO_MULTISIG", (CosmosSignerPublicKey.LEGACY_AMINO_MULTISIG, CosmosSignerPublicKey,), {})
CosmosSignerPublicKey.ANY = type("CosmosSignerPublicKey.ANY", (CosmosSignerPublicKey.ANY, CosmosSignerPublicKey,), {})




class FfiConverterTypeCosmosSignerPublicKey(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return CosmosSignerPublicKey.SINGLE(
                FfiConverterTypeCosmosAny.read(buf),
            )
        if variant == 2:
            return CosmosSignerPublicKey.LEGACY_AMINO_MULTISIG(
                FfiConverterTypeCosmosLegacyAminoMultisig.read(buf),
            )
        if variant == 3:
            return CosmosSignerPublicKey.ANY(
                FfiConverterTypeCosmosAny.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_single():
            buf.writeI32(1)
            FfiConverterTypeCosmosAny.write(value.key, buf)
        if value.is_legacy_amino_multisig():
            buf.writeI32(2)
            FfiConverterTypeCosmosLegacyAminoMultisig.write(value.key, buf)
        if value.is_any():
            buf.writeI32(3)
            FfiConverterTypeCosmosAny.write(value.key, buf)




class EthAbiTokenBind:
    def __init__(self):
        raise RuntimeError("EthAbiTokenBind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ADDRESS(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "EthAbiTokenBind.ADDRESS(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_address():
                return False
            if self.data != other.data:
                return False
            return True
    class FIXED_BYTES(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "EthAbiTokenBind.FIXED_BYTES(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_fixed_bytes():
                return False
            if self.data != other.data:
                return False
            return True
    class BYTES(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "EthAbiTokenBind.BYTES(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_bytes():
                return False
            if self.data != other.data:
                return False
            return True
    class INT(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "EthAbiTokenBind.INT(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_int():
                return False
            if self.data != other.data:
                return False
            return True
    class UINT(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "EthAbiTokenBind.UINT(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_uint():
                return False
            if self.data != other.data:
                return False
            return True
    class BOOL(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "EthAbiTokenBind.BOOL(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_bool():
                return False
            if self.data != other.data:
                return False
            return True
    class STR(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "EthAbiTokenBind.STR(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_str():
                return False
            if self.data != other.data:
                return False
            return True
    class FIXED_ARRAY(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "EthAbiTokenBind.FIXED_ARRAY(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_fixed_array():
                return False
            if self.data != other.data:
                return False
            return True
    class ARRAY(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "EthAbiTokenBind.ARRAY(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_array():
                return False
            if self.data != other.data:
                return False
            return True
    class TUPLE(object):
        def __init__(self,data):
            
            self.data = data
            

        def __str__(self):
            return "EthAbiTokenBind.TUPLE(data={})".format(self.data)

        def __eq__(self, other):
            if not other.is_tuple():
                return False
            if self.data != other.data:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_address(self):
        return isinstance(self, EthAbiTokenBind.ADDRESS)
    def is_fixed_bytes(self):
        return isinstance(self, EthAbiTokenBind.FIXED_BYTES)
    def is_bytes(self):
        return isinstance(self, EthAbiTokenBind.BYTES)
    def is_int(self):
        return isinstance(self, EthAbiTokenBind.INT)
    def is_uint(self):
        return isinstance(self, EthAbiTokenBind.UINT)
    def is_bool(self):
        return isinstance(self, EthAbiTokenBind.BOOL)
    def is_str(self):
        return isinstance(self, EthAbiTokenBind.STR)
    def is_fixed_array(self):
        return isinstance(self, EthAbiTokenBind.FIXED_ARRAY)
    def is_array(self):
        return isinstance(self, EthAbiTokenBind.ARRAY)
    def is_tuple(self):
        return isinstance(self, EthAbiTokenBind.TUPLE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
EthAbiTokenBind.ADDRESS = type("EthAbiTokenBind.ADDRESS", (EthAbiTokenBind.ADDRESS, EthAbiTokenBind,), {})
EthAbiTokenBind.FIXED_BYTES = type("EthAbiTokenBind.FIXED_BYTES", (EthAbiTokenBind.FIXED_BYTES, EthAbiTokenBind,), {})
EthAbiTokenBind.BYTES = type("EthAbiTokenBind.BYTES", (EthAbiTokenBind.BYTES, EthAbiTokenBind,), {})
EthAbiTokenBind.INT = type("EthAbiTokenBind.INT", (EthAbiTokenBind.INT, EthAbiTokenBind,), {})
EthAbiTokenBind.UINT = type("EthAbiTokenBind.UINT", (EthAbiTokenBind.UINT, EthAbiTokenBind,), {})
EthAbiTokenBind.BOOL = type("EthAbiTokenBind.BOOL", (EthAbiTokenBind.BOOL, EthAbiTokenBind,), {})
EthAbiTokenBind.STR = type("EthAbiTokenBind.STR", (EthAbiTokenBind.STR, EthAbiTokenBind,), {})
EthAbiTokenBind.FIXED_ARRAY = type("EthAbiTokenBind.FIXED_ARRAY", (EthAbiTokenBind.FIXED_ARRAY, EthAbiTokenBind,), {})
EthAbiTokenBind.ARRAY = type("EthAbiTokenBind.ARRAY", (EthAbiTokenBind.ARRAY, EthAbiTokenBind,), {})
EthAbiTokenBind.TUPLE = type("EthAbiTokenBind.TUPLE", (EthAbiTokenBind.TUPLE, EthAbiTokenBind,), {})




class FfiConverterTypeEthAbiTokenBind(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return EthAbiTokenBind.ADDRESS(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return EthAbiTokenBind.FIXED_BYTES(
                FfiConverterSequenceUInt8.read(buf),
            )
        if variant == 3:
            return EthAbiTokenBind.BYTES(
                FfiConverterSequenceUInt8.read(buf),
            )
        if variant == 4:
            return EthAbiTokenBind.INT(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return EthAbiTokenBind.UINT(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return EthAbiTokenBind.BOOL(
                FfiConverterBool.read(buf),
            )
        if variant == 7:
            return EthAbiTokenBind.STR(
                FfiConverterString.read(buf),
            )
        if variant == 8:
            return EthAbiTokenBind.FIXED_ARRAY(
                FfiConverterSequenceTypeEthAbiTokenBind.read(buf),
            )
        if variant == 9:
            return EthAbiTokenBind.ARRAY(
                FfiConverterSequenceTypeEthAbiTokenBind.read(buf),
            )
        if variant == 10:
            return EthAbiTokenBind.TUPLE(
                FfiConverterSequenceTypeEthAbiTokenBind.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_address():
            buf.writeI32(1)
            FfiConverterString.write(value.data, buf)
        if value.is_fixed_bytes():
            buf.writeI32(2)
            FfiConverterSequenceUInt8.write(value.data, buf)
        if value.is_bytes():
            buf.writeI32(3)
            FfiConverterSequenceUInt8.write(value.data, buf)
        if value.is_int():
            buf.writeI32(4)
            FfiConverterString.write(value.data, buf)
        if value.is_uint():
            buf.writeI32(5)
            FfiConverterString.write(value.data, buf)
        if value.is_bool():
            buf.writeI32(6)
            FfiConverterBool.write(value.data, buf)
        if value.is_str():
            buf.writeI32(7)
            FfiConverterString.write(value.data, buf)
        if value.is_fixed_array():
            buf.writeI32(8)
            FfiConverterSequenceTypeEthAbiTokenBind.write(value.data, buf)
        if value.is_array():
            buf.writeI32(9)
            FfiConverterSequenceTypeEthAbiTokenBind.write(value.data, buf)
        if value.is_tuple():
            buf.writeI32(10)
            FfiConverterSequenceTypeEthAbiTokenBind.write(value.data, buf)




class EthAmount:
    def __init__(self):
        raise RuntimeError("EthAmount cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class WEI_DECIMAL(object):
        def __init__(self,amount):
            
            self.amount = amount
            

        def __str__(self):
            return "EthAmount.WEI_DECIMAL(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_wei_decimal():
                return False
            if self.amount != other.amount:
                return False
            return True
    class GWEI_DECIMAL(object):
        def __init__(self,amount):
            
            self.amount = amount
            

        def __str__(self):
            return "EthAmount.GWEI_DECIMAL(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_gwei_decimal():
                return False
            if self.amount != other.amount:
                return False
            return True
    class ETH_DECIMAL(object):
        def __init__(self,amount):
            
            self.amount = amount
            

        def __str__(self):
            return "EthAmount.ETH_DECIMAL(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_eth_decimal():
                return False
            if self.amount != other.amount:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_wei_decimal(self):
        return isinstance(self, EthAmount.WEI_DECIMAL)
    def is_gwei_decimal(self):
        return isinstance(self, EthAmount.GWEI_DECIMAL)
    def is_eth_decimal(self):
        return isinstance(self, EthAmount.ETH_DECIMAL)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
EthAmount.WEI_DECIMAL = type("EthAmount.WEI_DECIMAL", (EthAmount.WEI_DECIMAL, EthAmount,), {})
EthAmount.GWEI_DECIMAL = type("EthAmount.GWEI_DECIMAL", (EthAmount.GWEI_DECIMAL, EthAmount,), {})
EthAmount.ETH_DECIMAL = type("EthAmount.ETH_DECIMAL", (EthAmount.ETH_DECIMAL, EthAmount,), {})




class FfiConverterTypeEthAmount(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return EthAmount.WEI_DECIMAL(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return EthAmount.GWEI_DECIMAL(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return EthAmount.ETH_DECIMAL(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_wei_decimal():
            buf.writeI32(1)
            FfiConverterString.write(value.amount, buf)
        if value.is_gwei_decimal():
            buf.writeI32(2)
            FfiConverterString.write(value.amount, buf)
        if value.is_eth_decimal():
            buf.writeI32(3)
            FfiConverterString.write(value.amount, buf)




class EthNetwork:
    def __init__(self):
        raise RuntimeError("EthNetwork cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class MAINNET(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "EthNetwork.MAINNET()".format()

        def __eq__(self, other):
            if not other.is_mainnet():
                return False
            return True
    class BSC(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "EthNetwork.BSC()".format()

        def __eq__(self, other):
            if not other.is_bsc():
                return False
            return True
    class CRONOS(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "EthNetwork.CRONOS()".format()

        def __eq__(self, other):
            if not other.is_cronos():
                return False
            return True
    class POLYGON(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "EthNetwork.POLYGON()".format()

        def __eq__(self, other):
            if not other.is_polygon():
                return False
            return True
    class KNOWN(object):
        def __init__(self,name):
            
            self.name = name
            

        def __str__(self):
            return "EthNetwork.KNOWN(name={})".format(self.name)

        def __eq__(self, other):
            if not other.is_known():
                return False
            if self.name != other.name:
                return False
            return True
    class CUSTOM(object):
        def __init__(self,chain_id, legacy):
            
            self.chain_id = chain_id
            self.legacy = legacy
            

        def __str__(self):
            return "EthNetwork.CUSTOM(chain_id={}, legacy={})".format(self.chain_id, self.legacy)

        def __eq__(self, other):
            if not other.is_custom():
                return False
            if self.chain_id != other.chain_id:
                return False
            if self.legacy != other.legacy:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_mainnet(self):
        return isinstance(self, EthNetwork.MAINNET)
    def is_bsc(self):
        return isinstance(self, EthNetwork.BSC)
    def is_cronos(self):
        return isinstance(self, EthNetwork.CRONOS)
    def is_polygon(self):
        return isinstance(self, EthNetwork.POLYGON)
    def is_known(self):
        return isinstance(self, EthNetwork.KNOWN)
    def is_custom(self):
        return isinstance(self, EthNetwork.CUSTOM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
EthNetwork.MAINNET = type("EthNetwork.MAINNET", (EthNetwork.MAINNET, EthNetwork,), {})
EthNetwork.BSC = type("EthNetwork.BSC", (EthNetwork.BSC, EthNetwork,), {})
EthNetwork.CRONOS = type("EthNetwork.CRONOS", (EthNetwork.CRONOS, EthNetwork,), {})
EthNetwork.POLYGON = type("EthNetwork.POLYGON", (EthNetwork.POLYGON, EthNetwork,), {})
EthNetwork.KNOWN = type("EthNetwork.KNOWN", (EthNetwork.KNOWN, EthNetwork,), {})
EthNetwork.CUSTOM = type("EthNetwork.CUSTOM", (EthNetwork.CUSTOM, EthNetwork,), {})




class FfiConverterTypeEthNetwork(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return EthNetwork.MAINNET(
            )
        if variant == 2:
            return EthNetwork.BSC(
            )
        if variant == 3:
            return EthNetwork.CRONOS(
            )
        if variant == 4:
            return EthNetwork.POLYGON(
            )
        if variant == 5:
            return EthNetwork.KNOWN(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return EthNetwork.CUSTOM(
                FfiConverterUInt64.read(buf),
                FfiConverterBool.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_mainnet():
            buf.writeI32(1)
        if value.is_bsc():
            buf.writeI32(2)
        if value.is_cronos():
            buf.writeI32(3)
        if value.is_polygon():
            buf.writeI32(4)
        if value.is_known():
            buf.writeI32(5)
            FfiConverterString.write(value.name, buf)
        if value.is_custom():
            buf.writeI32(6)
            FfiConverterUInt64.write(value.chain_id, buf)
            FfiConverterBool.write(value.legacy, buf)




class MnemonicWordCount(enum.Enum):
    TWELVE = 1
    EIGHTEEN = 2
    TWENTY_FOUR = 3
    


class FfiConverterTypeMnemonicWordCount(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return MnemonicWordCount.TWELVE
        if variant == 2:
            return MnemonicWordCount.EIGHTEEN
        if variant == 3:
            return MnemonicWordCount.TWENTY_FOUR
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == MnemonicWordCount.TWELVE:
            buf.writeI32(1)
        if value == MnemonicWordCount.EIGHTEEN:
            buf.writeI32(2)
        if value == MnemonicWordCount.TWENTY_FOUR:
            buf.writeI32(3)




class Network:
    def __init__(self):
        raise RuntimeError("Network cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CRYPTO_ORG_MAINNET(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Network.CRYPTO_ORG_MAINNET()".format()

        def __eq__(self, other):
            if not other.is_crypto_org_mainnet():
                return False
            return True
    class CRYPTO_ORG_TESTNET(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Network.CRYPTO_ORG_TESTNET()".format()

        def __eq__(self, other):
            if not other.is_crypto_org_testnet():
                return False
            return True
    class CRONOS_MAINNET(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Network.CRONOS_MAINNET()".format()

        def __eq__(self, other):
            if not other.is_cronos_mainnet():
                return False
            return True
    class COSMOS_HUB(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "Network.COSMOS_HUB()".format()

        def __eq__(self, other):
            if not other.is_cosmos_hub():
                return False
            return True
    class OTHER(object):
        def __init__(self,chain_id, coin_type, bech32hrp):
            
            self.chain_id = chain_id
            self.coin_type = coin_type
            self.bech32hrp = bech32hrp
            

        def __str__(self):
            return "Network.OTHER(chain_id={}, coin_type={}, bech32hrp={})".format(self.chain_id, self.coin_type, self.bech32hrp)

        def __eq__(self, other):
            if not other.is_other():
                return False
            if self.chain_id != other.chain_id:
                return False
            if self.coin_type != other.coin_type:
                return False
            if self.bech32hrp != other.bech32hrp:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_crypto_org_mainnet(self):
        return isinstance(self, Network.CRYPTO_ORG_MAINNET)
    def is_crypto_org_testnet(self):
        return isinstance(self, Network.CRYPTO_ORG_TESTNET)
    def is_cronos_mainnet(self):
        return isinstance(self, Network.CRONOS_MAINNET)
    def is_cosmos_hub(self):
        return isinstance(self, Network.COSMOS_HUB)
    def is_other(self):
        return isinstance(self, Network.OTHER)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Network.CRYPTO_ORG_MAINNET = type("Network.CRYPTO_ORG_MAINNET", (Network.CRYPTO_ORG_MAINNET, Network,), {})
Network.CRYPTO_ORG_TESTNET = type("Network.CRYPTO_ORG_TESTNET", (Network.CRYPTO_ORG_TESTNET, Network,), {})
Network.CRONOS_MAINNET = type("Network.CRONOS_MAINNET", (Network.CRONOS_MAINNET, Network,), {})
Network.COSMOS_HUB = type("Network.COSMOS_HUB", (Network.COSMOS_HUB, Network,), {})
Network.OTHER = type("Network.OTHER", (Network.OTHER, Network,), {})




class FfiConverterTypeNetwork(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return Network.CRYPTO_ORG_MAINNET(
            )
        if variant == 2:
            return Network.CRYPTO_ORG_TESTNET(
            )
        if variant == 3:
            return Network.CRONOS_MAINNET(
            )
        if variant == 4:
            return Network.COSMOS_HUB(
            )
        if variant == 5:
            return Network.OTHER(
                FfiConverterString.read(buf),
                FfiConverterUInt32.read(buf),
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_crypto_org_mainnet():
            buf.writeI32(1)
        if value.is_crypto_org_testnet():
            buf.writeI32(2)
        if value.is_cronos_mainnet():
            buf.writeI32(3)
        if value.is_cosmos_hub():
            buf.writeI32(4)
        if value.is_other():
            buf.writeI32(5)
            FfiConverterString.write(value.chain_id, buf)
            FfiConverterUInt32.write(value.coin_type, buf)
            FfiConverterString.write(value.bech32hrp, buf)




class RawRpcAccountResponse:
    def __init__(self):
        raise RuntimeError("RawRpcAccountResponse cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class OK_RESPONSE(object):
        def __init__(self,account):
            
            self.account = account
            

        def __str__(self):
            return "RawRpcAccountResponse.OK_RESPONSE(account={})".format(self.account)

        def __eq__(self, other):
            if not other.is_ok_response():
                return False
            if self.account != other.account:
                return False
            return True
    class ERROR_RESPONSE(object):
        def __init__(self,code, message, details):
            
            self.code = code
            self.message = message
            self.details = details
            

        def __str__(self):
            return "RawRpcAccountResponse.ERROR_RESPONSE(code={}, message={}, details={})".format(self.code, self.message, self.details)

        def __eq__(self, other):
            if not other.is_error_response():
                return False
            if self.code != other.code:
                return False
            if self.message != other.message:
                return False
            if self.details != other.details:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_ok_response(self):
        return isinstance(self, RawRpcAccountResponse.OK_RESPONSE)
    def is_error_response(self):
        return isinstance(self, RawRpcAccountResponse.ERROR_RESPONSE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
RawRpcAccountResponse.OK_RESPONSE = type("RawRpcAccountResponse.OK_RESPONSE", (RawRpcAccountResponse.OK_RESPONSE, RawRpcAccountResponse,), {})
RawRpcAccountResponse.ERROR_RESPONSE = type("RawRpcAccountResponse.ERROR_RESPONSE", (RawRpcAccountResponse.ERROR_RESPONSE, RawRpcAccountResponse,), {})




class FfiConverterTypeRawRpcAccountResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return RawRpcAccountResponse.OK_RESPONSE(
                FfiConverterTypeRawRpcAccountStatus.read(buf),
            )
        if variant == 2:
            return RawRpcAccountResponse.ERROR_RESPONSE(
                FfiConverterInt64.read(buf),
                FfiConverterString.read(buf),
                FfiConverterSequenceString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_ok_response():
            buf.writeI32(1)
            FfiConverterTypeRawRpcAccountStatus.write(value.account, buf)
        if value.is_error_response():
            buf.writeI32(2)
            FfiConverterInt64.write(value.code, buf)
            FfiConverterString.write(value.message, buf)
            FfiConverterSequenceString.write(value.details, buf)




class SingleCoin:
    def __init__(self):
        raise RuntimeError("SingleCoin cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class BASE_CRO(object):
        def __init__(self,amount):
            
            self.amount = amount
            

        def __str__(self):
            return "SingleCoin.BASE_CRO(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_base_cro():
                return False
            if self.amount != other.amount:
                return False
            return True
    class CRO(object):
        def __init__(self,amount, network):
            
            self.amount = amount
            self.network = network
            

        def __str__(self):
            return "SingleCoin.CRO(amount={}, network={})".format(self.amount, self.network)

        def __eq__(self, other):
            if not other.is_cro():
                return False
            if self.amount != other.amount:
                return False
            if self.network != other.network:
                return False
            return True
    class TESTNET_BASE_CRO(object):
        def __init__(self,amount):
            
            self.amount = amount
            

        def __str__(self):
            return "SingleCoin.TESTNET_BASE_CRO(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_testnet_base_cro():
                return False
            if self.amount != other.amount:
                return False
            return True
    class TESTNET_CRO(object):
        def __init__(self,amount):
            
            self.amount = amount
            

        def __str__(self):
            return "SingleCoin.TESTNET_CRO(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_testnet_cro():
                return False
            if self.amount != other.amount:
                return False
            return True
    class UATOM(object):
        def __init__(self,amount):
            
            self.amount = amount
            

        def __str__(self):
            return "SingleCoin.UATOM(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_uatom():
                return False
            if self.amount != other.amount:
                return False
            return True
    class ATOM(object):
        def __init__(self,amount):
            
            self.amount = amount
            

        def __str__(self):
            return "SingleCoin.ATOM(amount={})".format(self.amount)

        def __eq__(self, other):
            if not other.is_atom():
                return False
            if self.amount != other.amount:
                return False
            return True
    class OTHER(object):
        def __init__(self,amount, denom):
            
            self.amount = amount
            self.denom = denom
            

        def __str__(self):
            return "SingleCoin.OTHER(amount={}, denom={})".format(self.amount, self.denom)

        def __eq__(self, other):
            if not other.is_other():
                return False
            if self.amount != other.amount:
                return False
            if self.denom != other.denom:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_base_cro(self):
        return isinstance(self, SingleCoin.BASE_CRO)
    def is_cro(self):
        return isinstance(self, SingleCoin.CRO)
    def is_testnet_base_cro(self):
        return isinstance(self, SingleCoin.TESTNET_BASE_CRO)
    def is_testnet_cro(self):
        return isinstance(self, SingleCoin.TESTNET_CRO)
    def is_uatom(self):
        return isinstance(self, SingleCoin.UATOM)
    def is_atom(self):
        return isinstance(self, SingleCoin.ATOM)
    def is_other(self):
        return isinstance(self, SingleCoin.OTHER)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
SingleCoin.BASE_CRO = type("SingleCoin.BASE_CRO", (SingleCoin.BASE_CRO, SingleCoin,), {})
SingleCoin.CRO = type("SingleCoin.CRO", (SingleCoin.CRO, SingleCoin,), {})
SingleCoin.TESTNET_BASE_CRO = type("SingleCoin.TESTNET_BASE_CRO", (SingleCoin.TESTNET_BASE_CRO, SingleCoin,), {})
SingleCoin.TESTNET_CRO = type("SingleCoin.TESTNET_CRO", (SingleCoin.TESTNET_CRO, SingleCoin,), {})
SingleCoin.UATOM = type("SingleCoin.UATOM", (SingleCoin.UATOM, SingleCoin,), {})
SingleCoin.ATOM = type("SingleCoin.ATOM", (SingleCoin.ATOM, SingleCoin,), {})
SingleCoin.OTHER = type("SingleCoin.OTHER", (SingleCoin.OTHER, SingleCoin,), {})




class FfiConverterTypeSingleCoin(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return SingleCoin.BASE_CRO(
                FfiConverterUInt64.read(buf),
            )
        if variant == 2:
            return SingleCoin.CRO(
                FfiConverterUInt64.read(buf),
                FfiConverterTypeNetwork.read(buf),
            )
        if variant == 3:
            return SingleCoin.TESTNET_BASE_CRO(
                FfiConverterUInt64.read(buf),
            )
        if variant == 4:
            return SingleCoin.TESTNET_CRO(
                FfiConverterUInt64.read(buf),
            )
        if variant == 5:
            return SingleCoin.UATOM(
                FfiConverterUInt64.read(buf),
            )
        if variant == 6:
            return SingleCoin.ATOM(
                FfiConverterUInt64.read(buf),
            )
        if variant == 7:
            return SingleCoin.OTHER(
                FfiConverterString.read(buf),
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_base_cro():
            buf.writeI32(1)
            FfiConverterUInt64.write(value.amount, buf)
        if value.is_cro():
            buf.writeI32(2)
            FfiConverterUInt64.write(value.amount, buf)
            FfiConverterTypeNetwork.write(value.network, buf)
        if value.is_testnet_base_cro():
            buf.writeI32(3)
            FfiConverterUInt64.write(value.amount, buf)
        if value.is_testnet_cro():
            buf.writeI32(4)
            FfiConverterUInt64.write(value.amount, buf)
        if value.is_uatom():
            buf.writeI32(5)
            FfiConverterUInt64.write(value.amount, buf)
        if value.is_atom():
            buf.writeI32(6)
            FfiConverterUInt64.write(value.amount, buf)
        if value.is_other():
            buf.writeI32(7)
            FfiConverterString.write(value.amount, buf)
            FfiConverterString.write(value.denom, buf)




class TxBroadcastMode:
    def __init__(self):
        raise RuntimeError("TxBroadcastMode cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SYNC(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TxBroadcastMode.SYNC()".format()

        def __eq__(self, other):
            if not other.is_sync():
                return False
            return True
    class ASYNC(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TxBroadcastMode.ASYNC()".format()

        def __eq__(self, other):
            if not other.is__async():
                return False
            return True
    class COMMIT(object):
        def __init__(self,):
            
            pass
            

        def __str__(self):
            return "TxBroadcastMode.COMMIT()".format()

        def __eq__(self, other):
            if not other.is_commit():
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_sync(self):
        return isinstance(self, TxBroadcastMode.SYNC)
    def is__async(self):
        return isinstance(self, TxBroadcastMode.ASYNC)
    def is_commit(self):
        return isinstance(self, TxBroadcastMode.COMMIT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TxBroadcastMode.SYNC = type("TxBroadcastMode.SYNC", (TxBroadcastMode.SYNC, TxBroadcastMode,), {})
TxBroadcastMode.ASYNC = type("TxBroadcastMode.ASYNC", (TxBroadcastMode.ASYNC, TxBroadcastMode,), {})
TxBroadcastMode.COMMIT = type("TxBroadcastMode.COMMIT", (TxBroadcastMode.COMMIT, TxBroadcastMode,), {})




class FfiConverterTypeTxBroadcastMode(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return TxBroadcastMode.SYNC(
            )
        if variant == 2:
            return TxBroadcastMode.ASYNC(
            )
        if variant == 3:
            return TxBroadcastMode.COMMIT(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_sync():
            buf.writeI32(1)
        if value.is__async():
            buf.writeI32(2)
        if value.is_commit():
            buf.writeI32(3)




class WalletCoin:
    def __init__(self):
        raise RuntimeError("WalletCoin cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class COSMOS_SDK(object):
        def __init__(self,network):
            
            self.network = network
            

        def __str__(self):
            return "WalletCoin.COSMOS_SDK(network={})".format(self.network)

        def __eq__(self, other):
            if not other.is_cosmos_sdk():
                return False
            if self.network != other.network:
                return False
            return True
    class ETHEREUM(object):
        def __init__(self,network):
            
            self.network = network
            

        def __str__(self):
            return "WalletCoin.ETHEREUM(network={})".format(self.network)

        def __eq__(self, other):
            if not other.is_ethereum():
                return False
            if self.network != other.network:
                return False
            return True
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_cosmos_sdk(self):
        return isinstance(self, WalletCoin.COSMOS_SDK)
    def is_ethereum(self):
        return isinstance(self, WalletCoin.ETHEREUM)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
WalletCoin.COSMOS_SDK = type("WalletCoin.COSMOS_SDK", (WalletCoin.COSMOS_SDK, WalletCoin,), {})
WalletCoin.ETHEREUM = type("WalletCoin.ETHEREUM", (WalletCoin.ETHEREUM, WalletCoin,), {})




class FfiConverterTypeWalletCoin(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return WalletCoin.COSMOS_SDK(
                FfiConverterTypeNetwork.read(buf),
            )
        if variant == 2:
            return WalletCoin.ETHEREUM(
                FfiConverterTypeEthNetwork.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value.is_cosmos_sdk():
            buf.writeI32(1)
            FfiConverterTypeNetwork.write(value.network, buf)
        if value.is_ethereum():
            buf.writeI32(2)
            FfiConverterTypeEthNetwork.write(value.network, buf)


class CosmosError(Exception):

    # Each variant is a nested class of the error itself.
    # It just carries a string error message, so no special implementation is necessary.
    class EyreReport(Exception):
        pass
    class PubkeyError(Exception):
        pass

class FfiConverterTypeCosmosError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return CosmosError.EyreReport(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return CosmosError.PubkeyError(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, CosmosError.EyreReport):
            buf.writeI32(1)
        if isinstance(value, CosmosError.PubkeyError):
            buf.writeI32(2)


class EthError(Exception):

    # Each variant is a nested class of the error itself.
    # It just carries a string error message, so no special implementation is necessary.
    class Overflow(Exception):
        pass
    class HdWrapError(Exception):
        pass
    class HexConversion(Exception):
        pass
    class StrRadixConversion(Exception):
        pass
    class DecConversion(Exception):
        pass
    class ParseError(Exception):
        pass
    class NodeUrl(Exception):
        pass
    class SendTxFail(Exception):
        pass
    class BroadcastTxFail(Exception):
        pass
    class MempoolDrop(Exception):
        pass
    class BalanceFail(Exception):
        pass
    class AsyncRuntimeError(Exception):
        pass
    class ContractSendError(Exception):
        pass
    class ContractCallError(Exception):
        pass
    class SignatureError(Exception):
        pass
    class ChainidError(Exception):
        pass
    class AbiError(Exception):
        pass
    class Eip712Error(Exception):
        pass
    class JsonError(Exception):
        pass

class FfiConverterTypeEthError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return EthError.Overflow(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return EthError.HdWrapError(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return EthError.HexConversion(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return EthError.StrRadixConversion(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return EthError.DecConversion(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return EthError.ParseError(
                FfiConverterString.read(buf),
            )
        if variant == 7:
            return EthError.NodeUrl(
                FfiConverterString.read(buf),
            )
        if variant == 8:
            return EthError.SendTxFail(
                FfiConverterString.read(buf),
            )
        if variant == 9:
            return EthError.BroadcastTxFail(
                FfiConverterString.read(buf),
            )
        if variant == 10:
            return EthError.MempoolDrop(
                FfiConverterString.read(buf),
            )
        if variant == 11:
            return EthError.BalanceFail(
                FfiConverterString.read(buf),
            )
        if variant == 12:
            return EthError.AsyncRuntimeError(
                FfiConverterString.read(buf),
            )
        if variant == 13:
            return EthError.ContractSendError(
                FfiConverterString.read(buf),
            )
        if variant == 14:
            return EthError.ContractCallError(
                FfiConverterString.read(buf),
            )
        if variant == 15:
            return EthError.SignatureError(
                FfiConverterString.read(buf),
            )
        if variant == 16:
            return EthError.ChainidError(
                FfiConverterString.read(buf),
            )
        if variant == 17:
            return EthError.AbiError(
                FfiConverterString.read(buf),
            )
        if variant == 18:
            return EthError.Eip712Error(
                FfiConverterString.read(buf),
            )
        if variant == 19:
            return EthError.JsonError(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, EthError.Overflow):
            buf.writeI32(1)
        if isinstance(value, EthError.HdWrapError):
            buf.writeI32(2)
        if isinstance(value, EthError.HexConversion):
            buf.writeI32(3)
        if isinstance(value, EthError.StrRadixConversion):
            buf.writeI32(4)
        if isinstance(value, EthError.DecConversion):
            buf.writeI32(5)
        if isinstance(value, EthError.ParseError):
            buf.writeI32(6)
        if isinstance(value, EthError.NodeUrl):
            buf.writeI32(7)
        if isinstance(value, EthError.SendTxFail):
            buf.writeI32(8)
        if isinstance(value, EthError.BroadcastTxFail):
            buf.writeI32(9)
        if isinstance(value, EthError.MempoolDrop):
            buf.writeI32(10)
        if isinstance(value, EthError.BalanceFail):
            buf.writeI32(11)
        if isinstance(value, EthError.AsyncRuntimeError):
            buf.writeI32(12)
        if isinstance(value, EthError.ContractSendError):
            buf.writeI32(13)
        if isinstance(value, EthError.ContractCallError):
            buf.writeI32(14)
        if isinstance(value, EthError.SignatureError):
            buf.writeI32(15)
        if isinstance(value, EthError.ChainidError):
            buf.writeI32(16)
        if isinstance(value, EthError.AbiError):
            buf.writeI32(17)
        if isinstance(value, EthError.Eip712Error):
            buf.writeI32(18)
        if isinstance(value, EthError.JsonError):
            buf.writeI32(19)


class HdWrapError(Exception):

    # Each variant is a nested class of the error itself.
    # It just carries a string error message, so no special implementation is necessary.
    class InvalidLength(Exception):
        pass
    class HdError(Exception):
        pass
    class AccountId(Exception):
        pass

class FfiConverterTypeHdWrapError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return HdWrapError.InvalidLength(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return HdWrapError.HdError(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return HdWrapError.AccountId(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, HdWrapError.InvalidLength):
            buf.writeI32(1)
        if isinstance(value, HdWrapError.HdError):
            buf.writeI32(2)
        if isinstance(value, HdWrapError.AccountId):
            buf.writeI32(3)


class PublicKeyBytesError(Exception):

    # Each variant is a nested class of the error itself.
    # It just carries a string error message, so no special implementation is necessary.
    class InvalidLength(Exception):
        pass

class FfiConverterTypePublicKeyBytesError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return PublicKeyBytesError.InvalidLength(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, PublicKeyBytesError.InvalidLength):
            buf.writeI32(1)


class RestError(Exception):

    # Each variant is a nested class of the error itself.
    # It just carries a string error message, so no special implementation is necessary.
    class RequestError(Exception):
        pass
    class MissingResult(Exception):
        pass
    class AsyncRuntimeError(Exception):
        pass
    class GrpcTransportError(Exception):
        pass
    class GrpcError(Exception):
        pass
    class ErrorReport(Exception):
        pass

class FfiConverterTypeRestError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return RestError.RequestError(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return RestError.MissingResult(
                FfiConverterString.read(buf),
            )
        if variant == 3:
            return RestError.AsyncRuntimeError(
                FfiConverterString.read(buf),
            )
        if variant == 4:
            return RestError.GrpcTransportError(
                FfiConverterString.read(buf),
            )
        if variant == 5:
            return RestError.GrpcError(
                FfiConverterString.read(buf),
            )
        if variant == 6:
            return RestError.ErrorReport(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, RestError.RequestError):
            buf.writeI32(1)
        if isinstance(value, RestError.MissingResult):
            buf.writeI32(2)
        if isinstance(value, RestError.AsyncRuntimeError):
            buf.writeI32(3)
        if isinstance(value, RestError.GrpcTransportError):
            buf.writeI32(4)
        if isinstance(value, RestError.GrpcError):
            buf.writeI32(5)
        if isinstance(value, RestError.ErrorReport):
            buf.writeI32(6)


class SecretKeyWrapError(Exception):

    # Each variant is a nested class of the error itself.
    # It just carries a string error message, so no special implementation is necessary.
    class InvalidBytes(Exception):
        pass
    class InvalidHex(Exception):
        pass

class FfiConverterTypeSecretKeyWrapError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return SecretKeyWrapError.InvalidBytes(
                FfiConverterString.read(buf),
            )
        if variant == 2:
            return SecretKeyWrapError.InvalidHex(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, SecretKeyWrapError.InvalidBytes):
            buf.writeI32(1)
        if isinstance(value, SecretKeyWrapError.InvalidHex):
            buf.writeI32(2)



class FfiConverterOptionalString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeBaseNft(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeBaseNft.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeBaseNft.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeCollection(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeCollection.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeCollection.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeDenom(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeDenom.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeDenom.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeOwner(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeOwner.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeOwner.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypePageRequest(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypePageRequest.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypePageRequest.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeRawRpcPubKey(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeRawRpcPubKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeRawRpcPubKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeCosmosSignerPublicKey(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeCosmosSignerPublicKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeCosmosSignerPublicKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeMnemonicWordCount(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeMnemonicWordCount.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeMnemonicWordCount.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeTxBroadcastMode(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeTxBroadcastMode.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeTxBroadcastMode.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt8.read(buf) for i in range(count)
        ]



class FfiConverterSequenceString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterString.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeBaseNft(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeBaseNft.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeBaseNft.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeCosmosAny(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeCosmosAny.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeCosmosAny.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeCosmosSignerInfo(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeCosmosSignerInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeCosmosSignerInfo.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeDenom(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeDenom.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeDenom.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeIdCollection(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeIdCollection.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeIdCollection.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeCosmosRawMsg(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeCosmosRawMsg.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeCosmosRawMsg.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeCosmosSdkMsg(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeCosmosSdkMsg.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeCosmosSdkMsg.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeEthAbiTokenBind(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeEthAbiTokenBind.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeEthAbiTokenBind.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeSingleCoin(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeSingleCoin.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeSingleCoin.read(buf) for i in range(count)
        ]


class FfiConverterTypePublicKeyBytesWrapper:
    @staticmethod
    def write(value, buf):
        FfiConverterSequenceUInt8.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterSequenceUInt8.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterSequenceUInt8.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterSequenceUInt8.lower(value)

def get_single_msg_sign_payload(tx_info,msg,sender_pubkey):
    tx_info = tx_info
    
    msg = msg
    
    sender_pubkey = sender_pubkey
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeCosmosError,_UniFFILib.common_ad00_get_single_msg_sign_payload,
        FfiConverterTypeCosmosSdkTxInfo.lower(tx_info),
        FfiConverterTypeCosmosSdkMsg.lower(msg),
        FfiConverterTypePublicKeyBytesWrapper.lower(sender_pubkey)))



def build_signed_single_msg_tx(tx_info,msg,secret_key):
    tx_info = tx_info
    
    msg = msg
    
    secret_key = secret_key
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeCosmosError,_UniFFILib.common_ad00_build_signed_single_msg_tx,
        FfiConverterTypeCosmosSdkTxInfo.lower(tx_info),
        FfiConverterTypeCosmosSdkMsg.lower(msg),
        FfiConverterTypeSecretKey.lower(secret_key)))



def get_msg_sign_payload(tx_info,msgs,sender_pubkey):
    tx_info = tx_info
    
    msgs = list(x for x in msgs)
    
    sender_pubkey = sender_pubkey
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeCosmosError,_UniFFILib.common_ad00_get_msg_sign_payload,
        FfiConverterTypeCosmosSdkTxInfo.lower(tx_info),
        FfiConverterSequenceTypeCosmosSdkMsg.lower(msgs),
        FfiConverterTypePublicKeyBytesWrapper.lower(sender_pubkey)))



def build_signed_msg_tx(tx_info,msgs,secret_key):
    tx_info = tx_info
    
    msgs = list(x for x in msgs)
    
    secret_key = secret_key
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeCosmosError,_UniFFILib.common_ad00_build_signed_msg_tx,
        FfiConverterTypeCosmosSdkTxInfo.lower(tx_info),
        FfiConverterSequenceTypeCosmosSdkMsg.lower(msgs),
        FfiConverterTypeSecretKey.lower(secret_key)))



def get_nft_issue_denom_signed_tx(tx_info,secret_key,id,name,schema):
    tx_info = tx_info
    
    secret_key = secret_key
    
    id = id
    
    name = name
    
    schema = schema
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeCosmosError,_UniFFILib.common_ad00_get_nft_issue_denom_signed_tx,
        FfiConverterTypeCosmosSdkTxInfo.lower(tx_info),
        FfiConverterTypeSecretKey.lower(secret_key),
        FfiConverterString.lower(id),
        FfiConverterString.lower(name),
        FfiConverterString.lower(schema)))



def get_nft_mint_signed_tx(tx_info,secret_key,id,denom_id,name,uri,data,recipient):
    tx_info = tx_info
    
    secret_key = secret_key
    
    id = id
    
    denom_id = denom_id
    
    name = name
    
    uri = uri
    
    data = data
    
    recipient = recipient
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeCosmosError,_UniFFILib.common_ad00_get_nft_mint_signed_tx,
        FfiConverterTypeCosmosSdkTxInfo.lower(tx_info),
        FfiConverterTypeSecretKey.lower(secret_key),
        FfiConverterString.lower(id),
        FfiConverterString.lower(denom_id),
        FfiConverterString.lower(name),
        FfiConverterString.lower(uri),
        FfiConverterString.lower(data),
        FfiConverterString.lower(recipient)))



def get_nft_edit_signed_tx(tx_info,secret_key,id,denom_id,name,uri,data):
    tx_info = tx_info
    
    secret_key = secret_key
    
    id = id
    
    denom_id = denom_id
    
    name = name
    
    uri = uri
    
    data = data
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeCosmosError,_UniFFILib.common_ad00_get_nft_edit_signed_tx,
        FfiConverterTypeCosmosSdkTxInfo.lower(tx_info),
        FfiConverterTypeSecretKey.lower(secret_key),
        FfiConverterString.lower(id),
        FfiConverterString.lower(denom_id),
        FfiConverterString.lower(name),
        FfiConverterString.lower(uri),
        FfiConverterString.lower(data)))



def get_nft_transfer_signed_tx(tx_info,secret_key,id,denom_id,recipient):
    tx_info = tx_info
    
    secret_key = secret_key
    
    id = id
    
    denom_id = denom_id
    
    recipient = recipient
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeCosmosError,_UniFFILib.common_ad00_get_nft_transfer_signed_tx,
        FfiConverterTypeCosmosSdkTxInfo.lower(tx_info),
        FfiConverterTypeSecretKey.lower(secret_key),
        FfiConverterString.lower(id),
        FfiConverterString.lower(denom_id),
        FfiConverterString.lower(recipient)))



def get_nft_burn_signed_tx(tx_info,secret_key,id,denom_id):
    tx_info = tx_info
    
    secret_key = secret_key
    
    id = id
    
    denom_id = denom_id
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeCosmosError,_UniFFILib.common_ad00_get_nft_burn_signed_tx,
        FfiConverterTypeCosmosSdkTxInfo.lower(tx_info),
        FfiConverterTypeSecretKey.lower(secret_key),
        FfiConverterString.lower(id),
        FfiConverterString.lower(denom_id)))



def get_account_details_blocking(api_url,address):
    api_url = api_url
    
    address = address
    
    return FfiConverterTypeRawRpcAccountResponse.lift(rust_call_with_error(FfiConverterTypeRestError,_UniFFILib.common_ad00_get_account_details_blocking,
        FfiConverterString.lower(api_url),
        FfiConverterString.lower(address)))



def get_account_balance_blocking(api_url,address,denom,version):
    api_url = api_url
    
    address = address
    
    denom = denom
    
    version = version
    
    return FfiConverterTypeRawRpcBalance.lift(rust_call_with_error(FfiConverterTypeRestError,_UniFFILib.common_ad00_get_account_balance_blocking,
        FfiConverterString.lower(api_url),
        FfiConverterString.lower(address),
        FfiConverterString.lower(denom),
        FfiConverterTypeBalanceApiVersion.lower(version)))



def simulate_blocking(grpc_url,raw_signed_tx):
    grpc_url = grpc_url
    
    raw_signed_tx = list(int(x) for x in raw_signed_tx)
    
    return FfiConverterUInt64.lift(rust_call_with_error(FfiConverterTypeRestError,_UniFFILib.common_ad00_simulate_blocking,
        FfiConverterString.lower(grpc_url),
        FfiConverterSequenceUInt8.lower(raw_signed_tx)))



def broadcast_tx_sync_blocking(tendermint_rpc_url,raw_signed_tx):
    tendermint_rpc_url = tendermint_rpc_url
    
    raw_signed_tx = list(int(x) for x in raw_signed_tx)
    
    return FfiConverterTypeTxBroadcastResult.lift(rust_call_with_error(FfiConverterTypeRestError,_UniFFILib.common_ad00_broadcast_tx_sync_blocking,
        FfiConverterString.lower(tendermint_rpc_url),
        FfiConverterSequenceUInt8.lower(raw_signed_tx)))



def construct_unsigned_eth_tx(from_hex,to_hex,amount,network,legacy_tx):
    from_hex = from_hex
    
    to_hex = to_hex
    
    amount = amount
    
    network = network
    
    legacy_tx = bool(legacy_tx)
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeEthError,_UniFFILib.common_ad00_construct_unsigned_eth_tx,
        FfiConverterString.lower(from_hex),
        FfiConverterString.lower(to_hex),
        FfiConverterTypeEthAmount.lower(amount),
        FfiConverterTypeEthNetwork.lower(network),
        FfiConverterBool.lower(legacy_tx)))



def build_signed_eth_tx(tx_info,network,secret_key):
    tx_info = tx_info
    
    network = network
    
    secret_key = secret_key
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeEthError,_UniFFILib.common_ad00_build_signed_eth_tx,
        FfiConverterTypeEthTxInfo.lower(tx_info),
        FfiConverterTypeEthNetwork.lower(network),
        FfiConverterTypeSecretKey.lower(secret_key)))



def get_eth_balance_blocking(address,web3api_url):
    address = address
    
    web3api_url = web3api_url
    
    return FfiConverterString.lift(rust_call_with_error(FfiConverterTypeEthError,_UniFFILib.common_ad00_get_eth_balance_blocking,
        FfiConverterString.lower(address),
        FfiConverterString.lower(web3api_url)))



def get_contract_balance_blocking(account_address,contract_details,web3api_url):
    account_address = account_address
    
    contract_details = contract_details
    
    web3api_url = web3api_url
    
    return FfiConverterString.lift(rust_call_with_error(FfiConverterTypeEthError,_UniFFILib.common_ad00_get_contract_balance_blocking,
        FfiConverterString.lower(account_address),
        FfiConverterTypeContractBalance.lower(contract_details),
        FfiConverterString.lower(web3api_url)))



def broadcast_eth_signed_raw_tx_blocking(raw_tx,web3api_url,polling_interval_ms):
    raw_tx = list(int(x) for x in raw_tx)
    
    web3api_url = web3api_url
    
    polling_interval_ms = int(polling_interval_ms)
    
    return FfiConverterTypeTransactionReceipt.lift(rust_call_with_error(FfiConverterTypeEthError,_UniFFILib.common_ad00_broadcast_eth_signed_raw_tx_blocking,
        FfiConverterSequenceUInt8.lower(raw_tx),
        FfiConverterString.lower(web3api_url),
        FfiConverterUInt64.lower(polling_interval_ms)))



def broadcast_sign_eth_tx_blocking(to_hex,amount,network,secret_key,web3api_url,polling_interval_ms):
    to_hex = to_hex
    
    amount = amount
    
    network = network
    
    secret_key = secret_key
    
    web3api_url = web3api_url
    
    polling_interval_ms = int(polling_interval_ms)
    
    return FfiConverterTypeTransactionReceipt.lift(rust_call_with_error(FfiConverterTypeEthError,_UniFFILib.common_ad00_broadcast_sign_eth_tx_blocking,
        FfiConverterString.lower(to_hex),
        FfiConverterTypeEthAmount.lower(amount),
        FfiConverterTypeEthNetwork.lower(network),
        FfiConverterTypeSecretKey.lower(secret_key),
        FfiConverterString.lower(web3api_url),
        FfiConverterUInt64.lower(polling_interval_ms)))



def broadcast_contract_approval_tx_blocking(approval_details,network,secret_key,web3api_url,polling_interval_ms):
    approval_details = approval_details
    
    network = network
    
    secret_key = secret_key
    
    web3api_url = web3api_url
    
    polling_interval_ms = int(polling_interval_ms)
    
    return FfiConverterTypeTransactionReceipt.lift(rust_call_with_error(FfiConverterTypeEthError,_UniFFILib.common_ad00_broadcast_contract_approval_tx_blocking,
        FfiConverterTypeContractApproval.lower(approval_details),
        FfiConverterTypeEthNetwork.lower(network),
        FfiConverterTypeSecretKey.lower(secret_key),
        FfiConverterString.lower(web3api_url),
        FfiConverterUInt64.lower(polling_interval_ms)))



def broadcast_contract_transfer_tx_blocking(transfer_details,network,secret_key,web3api_url,polling_interval_ms):
    transfer_details = transfer_details
    
    network = network
    
    secret_key = secret_key
    
    web3api_url = web3api_url
    
    polling_interval_ms = int(polling_interval_ms)
    
    return FfiConverterTypeTransactionReceipt.lift(rust_call_with_error(FfiConverterTypeEthError,_UniFFILib.common_ad00_broadcast_contract_transfer_tx_blocking,
        FfiConverterTypeContractTransfer.lower(transfer_details),
        FfiConverterTypeEthNetwork.lower(network),
        FfiConverterTypeSecretKey.lower(secret_key),
        FfiConverterString.lower(web3api_url),
        FfiConverterUInt64.lower(polling_interval_ms)))



def broadcast_contract_batch_transfer_tx_blocking(batch_transfer_details,network,secret_key,web3api_url,polling_interval_ms):
    batch_transfer_details = batch_transfer_details
    
    network = network
    
    secret_key = secret_key
    
    web3api_url = web3api_url
    
    polling_interval_ms = int(polling_interval_ms)
    
    return FfiConverterTypeTransactionReceipt.lift(rust_call_with_error(FfiConverterTypeEthError,_UniFFILib.common_ad00_broadcast_contract_batch_transfer_tx_blocking,
        FfiConverterTypeContractBatchTransfer.lower(batch_transfer_details),
        FfiConverterTypeEthNetwork.lower(network),
        FfiConverterTypeSecretKey.lower(secret_key),
        FfiConverterString.lower(web3api_url),
        FfiConverterUInt64.lower(polling_interval_ms)))



def bytes_to_hex(data):
    data = list(int(x) for x in data)
    
    return FfiConverterString.lift(rust_call(_UniFFILib.common_ad00_bytes_to_hex,
        FfiConverterSequenceUInt8.lower(data)))



def eth_sign_transaction(json_str,secret_key):
    json_str = json_str
    
    secret_key = secret_key
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeEthError,_UniFFILib.common_ad00_eth_sign_transaction,
        FfiConverterString.lower(json_str),
        FfiConverterTypeSecretKey.lower(secret_key)))



def eth_sign_transaction_with_chainid(json_str,secret_key,chain_id):
    json_str = json_str
    
    secret_key = secret_key
    
    chain_id = int(chain_id)
    
    return FfiConverterSequenceUInt8.lift(rust_call_with_error(FfiConverterTypeEthError,_UniFFILib.common_ad00_eth_sign_transaction_with_chainid,
        FfiConverterString.lower(json_str),
        FfiConverterTypeSecretKey.lower(secret_key),
        FfiConverterUInt64.lower(chain_id)))



__all__ = [
    "InternalError",
    "Network",
    "WalletCoin",
    "MnemonicWordCount",
    "SingleCoin",
    "CosmosSdkMsg",
    "CosmosRawMsg",
    "CosmosRawNormalMsg",
    "CosmosRawCryptoOrgMsg",
    "RawRpcAccountResponse",
    "BalanceApiVersion",
    "TxBroadcastMode",
    "CosmosModeInfo",
    "CosmosSignerPublicKey",
    "ContractApproval",
    "ContractBalance",
    "ContractTransfer",
    "ContractBatchTransfer",
    "EthAbiTokenBind",
    "EthAmount",
    "EthNetwork",
    "CosmosSdkTxInfo",
    "EthTxInfo",
    "Height",
    "RawRpcBalance",
    "RawRpcPubKey",
    "RawRpcAccountStatus",
    "TxBroadcastResult",
    "DenomMetadata",
    "CosmosAny",
    "CosmosAuthInfo",
    "CosmosFee",
    "CosmosLegacyAminoMultisig",
    "CosmosSignerInfo",
    "CosmosTxBody",
    "Denom",
    "BaseNft",
    "Owner",
    "IdCollection",
    "Collection",
    "PageRequest",
    "TransactionReceipt",
    "get_single_msg_sign_payload",
    "build_signed_single_msg_tx",
    "get_msg_sign_payload",
    "build_signed_msg_tx",
    "get_nft_issue_denom_signed_tx",
    "get_nft_mint_signed_tx",
    "get_nft_edit_signed_tx",
    "get_nft_transfer_signed_tx",
    "get_nft_burn_signed_tx",
    "get_account_details_blocking",
    "get_account_balance_blocking",
    "simulate_blocking",
    "broadcast_tx_sync_blocking",
    "construct_unsigned_eth_tx",
    "build_signed_eth_tx",
    "get_eth_balance_blocking",
    "get_contract_balance_blocking",
    "broadcast_eth_signed_raw_tx_blocking",
    "broadcast_sign_eth_tx_blocking",
    "broadcast_contract_approval_tx_blocking",
    "broadcast_contract_transfer_tx_blocking",
    "broadcast_contract_batch_transfer_tx_blocking",
    "bytes_to_hex",
    "eth_sign_transaction",
    "eth_sign_transaction_with_chainid",
    "WalletCoinFunc",
    "SecretKey",
    "HdWallet",
    "CosmosSdkClient",
    "CosmosParserWrapper",
    "EthAbiContract",
    "CosmosSigner",
    "EthSigner",
    "Client",
    "SecretKeyWrapError",
    "HdWrapError",
    "PublicKeyBytesError",
    "CosmosError",
    "RestError",
    "EthError",
]

